<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试矩阵]]></title>
    <url>%2F%E6%B5%8B%E8%AF%95%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[谈谈对各种测试方法做二维定位后形成的测试矩阵. 最近在ThoughtWorks的#TW洞见#栏目看到了测试矩阵的概念和介绍，觉得很有意思。也让我在另一种层面上理解了各种测试方法。 你晕了没相信大家在初学测试的时候一定听过下列测试名词：单元测试、集成测试、性能测试、API测试、UI测试、压力测试、冒烟测试等等。诸如此类，不胜枚举。这么多的“测试”不知道你晕了没，反正博主开始是挺晕的。 此外，不同的人对这些测试的理解也不尽相同，比如“单元测试”，在Java中，有人说一个类就是一个单元，有人说一个方法就是一个单元，甚至有人说一个完整的API就是一个单元。一千个人眼里有一千种单元测试。。。 测试矩阵 既然有这么多的测试方法，在实际的测试工作中，我们到底怎么测试呢。像上边说的，测试种类如此繁多，难于理解，所以在测试时也难以沟通。 其实，我们可以从两个维度来理解这些测试方法，并将其应用到实际工作中。 其中，第一个维度就是测试实现的层次和粒度，说白了就是测哪。是方法，类，还是API？是应用、系统、还是整个平台？ 而我们常说的性能测试，功能测试，安全测试等等，都可以归为第二个维度，即测试的目标，也就是测什么，咋测。 这两个维度结合起来就形成了下边的测试矩阵： 测哪\咋测 功能测试 集成测试 性能测试 安全测试 端到端 test test test test API test test test test 类 test test test test 方法 test test test test 有了这样的认识，以后进行测试工作时工作起来就方便多了。我们可以进行“方法级别的功能测试”、“API级别的性能测试”等等。这样，使测试内容变得更加清晰。 事实上，在实际测试工作中，大多数情况下都进行的是功能测试，而常常忽略了第二个维度，即咋测。所以，根据测试矩阵进行测试，可以避免这种问题。]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发与测试]]></title>
    <url>%2F%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%8E%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[对敏捷软件测试的学习与思考。 先来首Music: 与“敏捷开发”的初次接触开始接触到“敏捷”这个概念，是在公司实习的时候，因为所在项目组实行的是敏捷开发。后来又读了几本关于敏捷测试的书籍（软件测试的艺术第三版—Chapter9），有了更深入的理解。所以本文主要是博主的实习经历总结和读书笔记。 接下来我将从3个方面：What?（什么是敏捷开发）&amp;Why（为什么要实行敏捷开发）&amp;How（如何实施）来谈谈我对敏捷软件开发模式的理解。 What?敏捷开发简单来说，敏捷开发是一个以用户为中心、客户需求为导向的开发过程。强调客户合作、响应需求变化。是一种迭代式、增量式的开发模式。主要有以下特点： 依赖客户参与 测试驱动开发（TDD） 开发周期短 敏捷测试对应敏捷开发模式，敏捷测试要求每个人都参与到测试过程中，所以需要团队人员之间进行大量的沟通与协作。 客户：定义用例和程序属性参与验收测试 开发和测试：共同打造可以进行功能自动化的测试配件 与传统测试过程相比，敏捷测试主要有以下特征： 测试并不是一个独立的阶段，而是和开发过程紧密联系并驱动开发（TDD）。 开发者先创建单元测试用例（失败验证测试），然后实现软件单元代码。 敏捷测试依赖于自动化测试。 测试者要通过持续的测试反馈推动项目前行，并帮助开发者修复bug。 Why? 与传统软件开发模式相比，敏捷开发把客户的参与作为关键环节。这样引入了灵活性，提高客户满意度。 如今的客户总是需要能立即发布的高质量应用产品，使得传统开发模式不能适应这种激烈的市场竞争环境。所以大多数企业更青睐像敏捷开发一般，轻量化、快速的开发方法。 How?事实上，敏捷开发方法有很多种，比如：功能驱动开发（FDD）、开放统一过程等等。但最流行的是极限编程（XP）开发方法和Scrum（进度跟踪）项目管理方法。 XP是一种迭代式、增量式的开发模式，非常强调单元测试和验收测试，是现在最著名的敏捷方法。Scrum是一种迭代式、增量式的项目管理方法，适用于所有的敏捷方法，用来度量开发速度和进度。两者相辅相成，形成了现今最流行的敏捷开发模式。 XP编程面向对象的编程语言如Java/C#，都含有全功能的API，所以可以利用其迅速实现大型复杂应用。但正因如此，应用程序的质量经常得不到保证。 XP编程的目的就是短时间开发高质量的应用程序。所以，XP方法将主要精力集中在测试上，在产品设计阶段之后，必须首先生成单元测试用例，然后才编写代码通过测试。 XP开发模型用12个核心实践来驱动该过程： NO.1：需求分析（开发、客户、产品均参与） NO.2：小规模、递增发布（增加实在/可增值的新功能，频繁发布新版本） NO.3：系统隐喻（编程小组确认开发规则） NO.4：简要设计（实现简要设计，通过单元测试，不需重复设计，只要不停实现） NO.5：连续测试（编写模块之前先生成单元测试用例，模块在通过单元测试后才算完成，程序在通过所有单元测试和验收测试后才算结束） NO.6：重构（清理调整代码库，任何重构之后需重新进行所有单元测试） NO.7：结对编程（两位程序员在同一台机器协同开发代码库，便于对代码实时检查，提高缺陷发生纠正率） NO.8：代码的集体所有权（所有代码归全体程序员所有，不存在某一个程序员只开发某一个代码库） NO.9：持续集成（变更后的代码在通过单元测试之后将其集成到代码库中） NO.10：每周工作40小时（不允许加班，如果每周都全力工作了40个小时，就不需要加班，在版本发布的前一周例外） NO.11：客户在现场（编程小组可以随时与客户沟通） NO.12：按标准编码（所有的代码需要满足编程小组设计的系统隐喻） XP测试 为满足XP方法的流程和思想，XP测试强调连续测试。主要由两种类型的测试组成：单元测试和验收测试。 XP单元测试单元测试是XP测试采用的主要测试方法，具有两条规则： 1.所有的代码模块在编码开始前必须设计好单元测试用例（最主要的优点在于可以更好理解程序需求，排除混淆） 2.产品发布之前所有的代码模块必须通过单元测试 为了迎合项目进度，单元测试通常要用自动化测试套件来减轻单元测试负担，测试套件可以生成测试报告并对程序中出现的缺陷进行分类，帮助修复bug。 XP验收测试 验收测试是判断应用程序是否满足功能性和易用性及其他需求，在设计阶段，开发人员和客户设计验收测试，由客户执行。 验收测试需注意以下几点： 同单元测试一样，验收测试也可是自动化的。测试内容为计算/数据等，可用自动化测试；当测试内容为界面布局和颜色等，测试应该是非自动化的。 与单元测试相同，验收测试过程中发现多个bug时，应对其进行优先级排序，每次bug修正后都要重新执行验收测试。所以验收测试也算是一种回归测试。 一个完整XP项目的运作流程下表给出了一个完整XP项目应进行的流程： 步骤 内容 Step1 程序员与客户进行产品需求分析会议，决定产品使用场景 Step2 编程小组进行内部会议，将需求分解为独立的任务，并估计每个任务所需要的时间（StoryPoint） Step3 程序员向客户提交任务清单，并要求客户对任务清单进行优先级排序 Step4 编程小组根据程序员具备的能力，将任务分配给对应结对程序员 Step5 每对程序员按照程序需求和规格说明，编写相应任务的单元测试用例 Step6 每对程序员编写完成通过其单元测试用例的任务代码，期间不断对代码进行修改和重测，并对代码库进行整合和集成 Step7 编程小组发布应用程序的一个预览版本，由客户进行验收测试，并通过修改缺陷不断进行回归测试 Step8 程序员在验收测试成功的基础上发布产品版本 其他工作：程序员根据最新经验更新对客户需求的时间估计方式。]]></content>
      <categories>
        <category>学习小记</category>
      </categories>
      <tags>
        <tag>敏捷测试</tag>
        <tag>极限编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近在读的书籍安利]]></title>
    <url>%2F%E6%9C%80%E8%BF%91%E5%9C%A8%E8%AF%BB%E7%9A%84%E4%B9%A6%E7%B1%8D%E5%AE%89%E5%88%A9%2F</url>
    <content type="text"><![CDATA[读万里书，行万里路。 啦啦啦~博主又回来啦，距离上次更文已经一个多月了呢。结束了在公司的实习，过完了年，又回到了学校的怀抱。不过博主是一个爱学习的好孩子，所以这段时间发现了几本好看的书，特来跟宝宝们墙裂安利一波٩(๑&gt;◡&lt;๑)۶~ PS:后边会陆续更几篇博文的，敬请期待。。。 生活篇NO.1 《高效能人士的7个习惯》 这本书是博主在公司活动中的小礼物，尤记得行政小姐姐把书给我的时候拍拍我的肩膀说：要好好学习。。。此书旨在提高日常生活和工作的效率，书中提到的工作技巧不论何种行业均适用，教你如何做一个办事效率高的人。 NO.2 《软技能：代码之外的生存指南》 这本书是看了廖雪峰的读后感才开始看的，不要被书名骗了，整本书中没有任何关于技术的探讨，都是一些生活技巧和人生规划的建议，非常值得一看。书中包括但不限于健身、理财等方面的知识，对生活实践很有帮助。 PS：博主对书中学习如何学习的部分深以为然，作者提倡先实践，再学习。 工作篇NO.1 《软件测试的艺术》 这本书是软件测试入门的元老级书籍，建议看第三版，第二版虽然基础但是内容不多，第三版中加入了很多最新热门的技术领域，第9章中对敏捷开发模式下的测试做了详细介绍，非常引人入胜。 NO.2 《敏捷软件测试：测试人员与敏捷团队的实战指南》 这本书对敏捷测试做了深入剖析，建议在看完上本书之后再看，收获会更大。是一本敏捷团队中的测试人员必读书籍，非常经典。]]></content>
      <categories>
        <category>读书使我快乐</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的文件备份了吗？]]></title>
    <url>%2F%E4%BD%A0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E4%BA%86%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[还在用电脑和U盘保存你的文件吗？ 文件备份的重要性今天不小心删了一个虚拟机文件，然后，虚拟机里所有的文件都没了。。 我的心在滴血555 这个故事告诉我们，电脑里的文件一定要备份，因为有下面3种可能导致文件消失： 电脑坏了/丢了 U盘坏了/丢了 自己手贱删了 我的建议 经过博主长期的实践，推荐两款产品进行文件备份：百度网盘/坚果云 百度网盘这个算是很大众的产品了，相信很多小伙伴都在用： 它的优点是容量大，缺点是不能自动上传文件，所以需要你自己每隔一段时间维护一次。所以建议你把文件分门别类的放好，这样也好管理。 坚果云第一次用坚果云的小伙伴，一定会觉得这是个神器。因为相较于百度网盘，坚果云的最大好处就是可以自动识别发生变化的文件，并将其上传。 在下方创建一个同步文件夹，之后就会自动上传，不用手动维护： 缺点是一个账号免费流量只有1G，所以只能保存一些文本文件： 但因为坚果云是用邮箱来注册的，所以我们可以多注册几个账号，这样流量就多啦~。可以多注册几个163字母邮箱（一天只能注册3个）。 总结一下根据百度网盘和坚果云特点，我们可以把一些大的、不常更新的文件定期上传到百度网盘里，比如：视频/软件安装包等等。 而一些小的，经常更新的文件用坚果云来同步，比如文本文件。 By The Way…最后，给大家推荐一篇大神博客，里面安利了各种值得用的软件/硬件产品：个人成长基础设施：纪念那些年我折腾过的各种… 亲们如果有什么更好的文件备份方法，可以在评论里向我推荐，感激不尽。。。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>文件备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类中的代码块执行顺序]]></title>
    <url>%2Fjava%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[代码实例分析java类中的代码块执行顺序. 一道笔试题下面是一道阿里的java校招笔试题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class HelloA&#123; //构造方法 public HelloA() &#123; System.out.println("父类构造方法"); &#125; //非静态代码块 &#123; System.out.println("父类非静态代码块"); &#125; //静态代码块 static&#123; System.out.println("父类静态代码块"); &#125;&#125;class HelloB extends HelloA&#123; //构造方法 public HelloB() &#123; System.out.println("子类构造方法"); &#125; //非静态代码块 &#123; System.out.println("子类非静态代码块"); &#125; //静态代码块 static&#123; System.out.println("子类静态代码块"); &#125; &#125;public class Test&#123; public static void main(String[] args) &#123; new HelloB(); new HelloB(); &#125;&#125; 请写出上述代码的输出，看完本文你就会有答案。 代码块分类及其执行顺序代码块分类代码块，就是使用”{}”定义的一段代码，根据代码块定义的位置和关键字，可分为以下四种： 普通代码块：定义在类的方法中的代码块。 构造块：定义在类中的代码块（无修饰符）。 静态代码块：使用static修饰的，在类中定义的代码块。 同步代码块（与多线程有关，本文不涉及） 执行顺序（无继承）看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person&#123; public Person() &#123; System.out.println("非主类构造方法"); &#125; &#123; System.out.println("非主类构造块,优于构造方法执行"); &#125; static &#123; System.out.println("非主类静态块，优于构造块执行，无论产生多少实例化对象，只执行一次。"); &#125; &#125;public class Hello&#123; public Hello() &#123; System.out.println("主类构造方法"); &#125; public static void main(String[] args) &#123; System.out.println("----start----"); new Hello(); new Person(); new Person(); new Hello(); System.out.println("-----end-----"); &#125; &#123; System.out.println("主类构造块"); &#125; static&#123; System.out.println("主类静态块，优于主方法执行"); &#125;&#125; 执行结果： 结论： 其中： 主类静态块优于主方法执行。 无论生成多少类对象，静态块只执行一次。 主类和非主类的构造方法、构造块谁先执行取决于代码顺序，与主类/非主类无关。 执行顺序（有继承）我们知道，在继承的情况下，子类在实例化时，首先调用父类的构造方法，然后再调用子类的构造方法。因此，结合上面的结论，我们就可以得出开始那道笔试题的结果。 为了方便观察，对代码改动如下： 1234567891011public class Test&#123; public static void main(String[] args) &#123; System.out.println("----start----"); System.out.println("---first---"); new HelloB();//first System.out.println("---second---"); new HelloB();//second System.out.println("-----end-----"); &#125;&#125; 答案在这里：]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>javaEE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未来是星辰大海]]></title>
    <url>%2F%E6%9C%AA%E6%9D%A5%E6%98%AF%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7%2F</url>
    <content type="text"><![CDATA[今天去签了三方，所以，我的大学生活也许真的要结束了。 大学三年以前常听别人说，大学其实只有短短三年。开始我是不信的，现在却不得不信了。 大四安排大四刚开始，金九银十。秋招开始了： 大佬：一个offer接一个offer，择优录取 我：找了一个offer，得，还不错，签了吧 没错，作为第一次面试就拿到了offer，还签了三方的我。确实是一个很容易满足的人，当然，这跟实力也有关系，我等渣滓不敢跟大佬比。。。 其实offer拿到有段时间了，到今天才去签。（中间那段时间把段位从黄金升到了铂金，再也没人说我是黄金狗了），当然，还干了点别的事情。 唉，本来想深沉一下，咋越写越欢脱。。。 后边的安排可能就是先把照学到手，不过最近改革了，估计很难成为老司机的一员了。然后去实习，春节前刚好结束（说不定还能参加下公司年会）。 学期末确定下毕设题目，然后开整。解决完了去旅个游，毕竟大学生优惠什么的不能浪费。。。 然后毕业照走一波，之后再去公司报到，咱也是社会人了。 三年回首这个只能在心里默默吐槽了，不过怎么说呢，有句话是成长的过程就是越来越觉得以前的自己是个xx的过程。 嗯，我想了一想，说的还真对。 那些让我后悔的事 说实话，还真没啥。 说自己没好好学习吧，那是我懒我认了。不过咱好歹还拿过奖学金不是~ 说自己没挂过科把，谁说的，挂过一门。。。（说起来既拿过奖学金，又挂过科的，估计我也是独一份） 说没谈过恋爱吧，有那个时间我还不如去睡觉，省事省心还自由不是~ 其实吧，哪有那么多后悔的事情。 人嘛，该干嘛的时候就得干嘛，每个时间段都有自己该做的事情。做完了你才有资格搞其它有的没的。结果是你自己没做，后来又说后悔，你说这不是耍流氓这是啥？ 或许你觉得当时没有做好，但人的身心发展都是分阶段的，几年之后再回想之前做的事情，肯定觉得不对味呀。人要是一直钻这个牛角尖，那就没啥意思了。 对未来的一点小小畅想梦想还是要有的，万一实现了呢。 想要坚持的 健身（身体最重要） 读书（腹有诗书气自华（老脸一红）） 学习（行业特殊，为了不被淘汰掉，坚持学习真的很重要） 坚持给父母的全民K歌账号打call（真的超爱唱歌） 除了最后一条，我还真不敢保证每天都做，毕竟谁都不是圣人。但是要尽量坚持下去。 想要实现的等我有钱了，要啥啥没有？┑(￣Д ￣)┍ 其它有的没的都在心里。 好了，也该收收心了。看这个日子，上次发文都在一月前了。之后得给自己博客上点干货了。]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>未来</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[对近几天的git学习做一个小结。 学完了廖雪峰的git教程，对git的概念和基本操作有了更深的理解。对“版本控制”的概念也理解的更加深刻。 几点感受以下是我学习了git之后的一些感受： 成为了Linus Benedict Torvalds的一枚小迷妹（以前也是，现在妥妥的）。 世上没有后悔药？不存在的，git的版本回退完美的实现了这一点。 搞清楚了git和github的关系，后者只是拥有一个git远程仓库，可以通过git连接并实现相应操作。 Git服务器可以轻松搭建，除了github，还有coding/gitee等网站提供git服务。 工作效率真的提升很快。。。 干货下面对学习中涉及到的git命令做分类总结，都是最常用的。 git本地管理 git最基本的一些操作 git init：将某目录变成git可以管理的仓库（添加.git目录） git commit -m “…”:一次性提交多个文件（add进来的文件） git add xxx.md:可以多次添加多个不同文件 git status:可以时刻掌握仓库当前的状态 git diff:显示具体修改的内容（与提交进去的文件相比） git log：显示从最近到最远的提交日志，加上–pretty=oneline参数可以将每次提交信息压缩成一行,最前边的数字加字母是指每次commit的commit-id,是16进制的表示形式 .gitignore文件：包括git需要忽略提交的文件名，此文件也需要提交到git 版本回退 世界上是有后悔药的 git reset –hard HEAD^:回退到上个版本（上上个版本HEAD^^,上100个版本是HEAD~100。HEAD是指向当前版本的指针，因此可以通过调整HEAD来在历史版本间穿梭） git reset –hard commmitid：在没有关闭上次回退时的命令窗口时，可以取消回退。commitid没必要写全，git可以自己去找 git reflog:可以显示每一次commit和回退的id号，如果命令窗口关闭，可以用此命令先找到commitid，然后用上个命令取消回退 git checkout – file：撤销在工作区对file做的修改，包括撤销对file文件的删除 git reset HEAD file &amp; git checkout – file：对file的修改已被add到stage，用前者删除add到stage的修改，再用后者撤销工作区的修改 git reset –hard HEAD^ :已经将想撤销的修改添加到了版本库，但还未提交到远程库。用版本回退撤销修改 git rm file&amp;git commit -m “delete file”：删除已添加到版本库的文件 git checkout:用版本库里的文件版本替换工作区的文件版本（一键还原） 远程库连接 连接远程库，进一步实现团队协作。 git remote:查看远程库信息，详细信息加上-v选项 git remote add origin git@github.com:Summyj/xxx.git：将本地git仓库与github远程库想关联,也可以是其它库，远程库默认名字是origin，也可以设为其它，比如github git push -u origin xxx:把本地仓库指定分支·内容推送到远程，下次推送可以不用-u参数因为第一次推送master分支时如果加上-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，所以在以后的推送或者拉取时就可以简化命令。 git clone git@github.com:xxx/xxx.git:从远程仓库克隆到本地，后边是地址 git remotr rm origin:删除本地库关联的origin远程库 分支创建管理 实现更安全便捷的版本控制。 git checkout -b xxx:git check命令加上-b参数表示创建并切换到xxx分支，此命令相当于两条命令： git branch xxx git checkout xxx git branch:查看当前分支（列出所有分支，当前分支前边会标有*号） git merge xxx:将指定分支xxx合并到当前分支,首先要切换到当前分支（不一定是master分支） git branch -d xxx:删除某分支（合并后再删除） git branch -D xxx:强行删除某个没有被合并的分支 git log –graph –pretty=oneline –abbrev-commit：用分支图展示各分支合并情况（或者直接git log –graph，但这将会显示所有历史合并图） git merge –no-ff -m “…” xxx:禁用git合并时默认的fast-forward模式，生成新的commit加入分支信息。-m后的内容就是合并信息 工作现场存储 版本控制的freestyle. git stash:将当前工作现场储藏起来，等以后恢复现场后继续工作 git stash list:查看储藏的工作现场 git stash apply:回复储藏的工作现场 git stash apply stash@{x}有多个stash时恢复指定的stash git stash drop:恢复现场并删除stash list的内容，如果有多个stash,默认恢复的是最新的stash. 多人协作 小伙伴们的友情 git checkout -b xxx origin/xxx:刚从远程库克隆到本地时只有master分支，用此命令创建和远程分支对应的分支 git pull:多人协作时，远程分支比本地分支更新导致推送失败，用此命令从远程库抓取该分支最新的提交并和本地分支进行合并，合并有冲突需要手动解决 git branch –set-upstream xxx origin/xxx:git pull失败时需要创建本地分支和远程分支的关联 标签管理 更方便进行版本控制，与commit id相比更好记。相当于版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针。与HEAD指针相比，后者可以移动，但标签不能移动），所以，创建和删除标签都是瞬间完成的。 git tag xxx:打标签 git tag v0.3 646123:将commit id为646123的提交打上v0.3标签。这样可以解决忘记打标签的问题 git tag:查看所有标签（按字母排序，而并非时间） git show tagname:查看标签信息（包括说明文字） git tag -a v0.x -m “…” 615465:创建带有说明的标签，用-a指定标签名，-m指定说明文字 git tag -d xxx:删除指定标签（因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。） git push origin tagname:推送标签到远程 git push origin –tags:一次性推送全部尚未推送到远程的本地标签 git tag -d tagname &amp; git push origin :refs/tags/tagname:删除已推送到远程库的标签，先从本地删除，再从远程删除]]></content>
      <categories>
        <category>学习小记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解socket?]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3socket%2F</url>
    <content type="text"><![CDATA[Socket是系统提供的、为了使用TCP/IP协议栈而设置的网络编程调用接口(API). Socket是什么?概述要写网络程序就必须用Socket，这是程序员都知道的。 socket是一个对tcp\ip这个网络通讯协议栈的全面封装与实现。 一般来说，很多人都会说Socket编程基本就是listen，accept以及send，write等几个基本的操作。是的，就跟常见的文件操作一样，只要写过就一定知道。对于网络编程，我们也言必称TCP/IP，似乎其它网络协议已经不存在了。 深入理解一个疑问我们知道，一个指定的端口号不能被多个程序共用。比如：如果IIS占用了80端口，那么Apache就不能也用80端口了很多防火墙只允许特定目标端口的数据包通过服务程序在listen某个端口并accept某个连接请求后，会生成一个新的socket来对该请求进行处理。 于是，一个困惑了我很久的问题就产生了。如果一个socket创建后并与80端口绑定后，是否就意味着该socket占用了80端口呢？ 如果是这样的，那么当其accept一个请求后，生成的新的socket到底使用的是什么端口呢（我一直以为系统会默认给其分配一个空闲的端口号）？如果是一个空闲的端口，那一定不是80端口了，于是以后的TCP数据包的目标端口就不是80了–防火墙一定会组织其通过的！实际上，我们可以看到，防火墙并没有阻止这样的连接，而且这是最常见的连接请求和处理方式。 我的不解就是，为什么防火墙没有阻止这样的连接？它是如何判定那条连接是因为connet80端口而生成的？是不是TCP数据包里有什么特别的标志？或者防火墙记住了什么东西？ 解决疑问后来，我又仔细研读了TCP/IP的协议栈的原理，对很多概念有了更深刻的认识。 比如，在TCP和UDP同属于传输层，共同架设在IP层（网络层）之上。而IP层主要负责的是在节点之间（End to End）的数据包传送，这里的节点是一台网络设备，比如计算机。 因为IP层只负责把数据送到节点（计算机），而不能区分上面的不同应用，所以TCP和UDP协议在其基础上加入了端口的信息，端口于是标识的是一个节点上的一个应用。 除了增加端口信息，UPD协议基本就没有对IP层的数据进行任何的处理了。而TCP协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口（Slice Window），以及接收确认和重发机制，以达到数据的可靠传送。 不管应用层看到的是怎样一个稳定的TCP数据流，下面传送的都是一个个的IP数据包，需要由TCP协议来进行数据重组。所以，我有理由怀疑，防火墙并没有足够的信息判断TCP数据包的更多信息，除了IP地址和端口号。 而且，我们也看到，所谓的端口，是为了区分不同的应用的，以在不同的IP包来到的时候能够正确转发。TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。 就像操作系统会提供标准的编程接口，比如Win32编程接口一样，TCP/IP也必须对外提供编程接口，这就是Socket编程接口–原来是这么回事啊！ 为什么要用Socket?这个问题就要讨论一下socket与TCP/IP协议的关系了。 理论与实践协议只是一个概念，是一种规范和约定俗成的东西，我想要操作和应用这些协议，那它必须要有一个实现，socket就是这个实现。 通过使用socket的一系列api,比如说connect,write,read 它能够依照tcp/ip的规范实现网络通讯。即socket是成对出现的，客户端一个socket,服务端一个socket,通过对它的一系列操作来实现tcp/ip的规范的功能。 即socket连接也就是tcp连接的实现。我们在平时开发的过程中，关于网络通讯，其实本质封装的就是socket。因为tcp/ip是协议，协议是概念，具体实现的还是socket。 抽象实现socket跟TCP/IP并没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以，socket的出现只是可以更方便的使用TCP/IP协议栈而已，其对TCP/IP进行了抽象，形成了几个最基本的函数接口。比如create，listen，accept，connect，read和write等等。 socket只是对TCP/IP协议栈操作的抽象，而不是简单的映射关系。 实现细节现在我们明白，如果一个程序创建了一个socket，并让其监听80端口，其实是向TCP/IP协议栈声明了其对80端口的占有。 以后，所有目标是80端口的TCP数据包都会转发给该程序（这里的程序，因为使用的是Socket编程接口，所以首先由Socket层来处理）。 所谓accept函数，其实抽象的是TCP的连接建立过程：accept函数返回的新socket其实指代的是本次创建的连接，而一个连接是包括两部分信息的，一个是源IP和源端口，另一个是宿IP和宿端口。所以，accept可以产生多个不同的socket，而这些socket里包含的宿IP和宿端口是不变的，变化的只是源IP和源端口。 这样的话，这些socket宿端口就可以都是80，而Socket层还是能根据源/宿对来准确地分辨出IP包和socket的归属关系，从而完成对TCP/IP协议的操作封装！ 总结 SOCKET：套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。 Socket是对TCP/IP协议的封装，Socket本身只是一个调用接口（API），方便程序员用Socket使用TCP/IP协议栈而已. 本文转载自知乎，原文链接：谈谈你对socket的理解]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>网络编程</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程剖析（part2)—线程控制及线程属性]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E5%89%96%E6%9E%90%EF%BC%88part2-%E2%80%94%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[本篇博文将重点从两个方面：线程控制（线程等待、线程终止）及线程属性来进一步分析线程特点。 线程终止首先，我们需要知道线程终止的几种方式： 1.从线程函数中return（特殊：从main函数中return，代表进程退出，也代表主线程退出。那么此时线程必定被终止。） 2.直接调用pthread_exit函数终止线程（注意：在线程内调用exit终止的是进程而非线程） 3.调用pthread_cancel函数来取消线程，从而终止线程。 与线程终止有关的函数： 下面我们来编写代码实现线程终止。 用pthread_exit函数终止线程 运行结果： 用命令查看，该进程是单进程。 用pthread_cancel函数取消线程 从主线程中取消新线程： 执行结果： 线程自己取消自己： 执行结果： 线程等待对于线程等待，我们需要知道以下几点： 1.线程一旦出错，必须由进程承担后果。对于线程，我们只关心它的两种运行情况： 代码跑完了，结果正确 代码跑完了，结果不正确 如果代码都没跑完，中途退出。这意味着进程也会退出，所以就无法查看其退出原因。 2.线程出错，导致进程退出。则属于该进程的其他线程也会退出，因为线程的资源由进程分配。所以一般多进程比多线程的程序稳定。 因为多线程程序的不稳定性， 如果一个线程结束运行但没有被join，则它的状态类似于进程中的僵尸进程， 即还有一部分资源没有被回收，导致内存泄漏。所以创建线程者应该调⽤pthread_join来等待线程运行结束，并可得到线程的退出码来回收其资源。 线程等待函数：pthread_join表达式： 调⽤用该函数的线程将挂起等待,直到id为thread的线程终止。 若thread线程以不同的方法终止,通过pthread_join得到的终止状态是不同的,总结如下: 如果thread线程通过return返回retval所指向的单元⾥里存放的是thread线程函数的返回值。 如果thread线程被别的线程调用pthread_cancel异常终止掉,retval所指向的单元⾥里存放的是常数PTHREAD_CANCELED。 如果thread线程自己调用pthread_exit终止,retval所指向的单元存放的是传给 pthread_exit的参数。 如果对thread线程的终止状态不感兴趣,可以传NULL给retval参数。 下面我们来编写程序实现进程等待。 为了对比方便，将上述retval返回值的所有可能情况汇总在一起： 得到如下结果： 至此，线程控制结束。 线程属性总的来说，在任何一个时间点上。线程有两种属性： 1.可结合（joinable）属性：线程的默认属性。能够被其他线程收回其资源和杀死，在被其他线程回收之前，它的存储器资源 （例如栈）是不释放的。 2.分离（detached）属性：不能被其他线程回收或杀死，它的存储器资源在它终止时由系统⾃自动释放。 注：为了避免存储器泄漏，每个可结合线程都应该要么被显示地回收，即调用pthread_join；要么通过调用pthread_detach函数被分离。 线程分离函数pthread_detach 下面通过代码实现线程分离： 因为线程分离后就不能再被等待，所以在程序中加入等待函数，如果线程分离成功，就会打印出错信息。 运行结果如下： 等待函数打印出错信息，线程分离成功 The End由于调用pthread_join后，如果该线程没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此。 例如，在Web服务器中当主线程为每个新来的连接请求创建⼀个子线程进行处理的时候，主线程并不希望因为调用pthread_join⽽而阻塞（因为还要继续处理之后到来的连接请求）。这时可以在子线程中加入代码 pthread_detach(pthread_self()) 或者主线程调用pthread_detach(thread_id)（非阻塞，可立即返回） 。 将子线程的状态设置为分离的（detached），如此一来，该线程运行结束后会自动释放所有资源。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux线程剖析（Part1）—1个假的tcb]]></title>
    <url>%2Flinux%E7%BA%BF%E7%A8%8B%E5%89%96%E6%9E%90%EF%BC%88Part1%EF%BC%89%E2%80%941%E4%B8%AA%E5%81%87%E7%9A%84tcb%2F</url>
    <content type="text"><![CDATA[线程基本概念介绍 linux的“假”线程先说一句废话：线程是在进程内部运行的一个执行分支。 这是现在大多数计算机书籍对线程概念的描述。然而，对大多数人来说（比如我），仍然不(yi)知(lian)所(meng)云(bi)。 为了深刻理解这句话背后的含义，我们先来看一张图： 我们知道，vfork函数是用来创建子进程的。且该函数创建出的子进程与父进程共用一个地址空间。 所以，可以将父进程中的代码和函数分解，并分别交给这些子进程并行执行。这种方式相较于普通进程执行的方案更为高效。 事实上，我们可以将这些子进程看作线程，而把上图中的father和child统称为一个进程。这样，我们就可以知道线程在进程和OS中扮演的角色。 那为什么说linux的线程是“假”的呢？ 这是因为在linux中，线程和进程共用了一种数据结构（task_struct）。也就是说，linux并没有为线程设计另外的数据结构。linux中的线程是由进程模拟的。所以，linux中没有真正意义上的线程，相当于“假”的线程。 注：windows操作系统中，线程就是真正意义上的线程。每一个线程都有一个”tcb”，每一个进程则都有一个”pcb”，两者各有自己的数据结构来表示。 轻量级线程：如果有一个进程，它只有一个线程（一个pcb），这种进程就叫做“单进程”，所以，linux中的某些进程也可以当作线程来看待。正是这一点决定了linux进程比其他系统的进程量级清，粒度小。因此，linux下的进程又叫做”轻量级进程“。 那么进程和线程之间有什么区别呢？我们通过一张表来加深理解： 线程的共有/私有资源 由于同⼀进程的多个线程共享同⼀地址空间,因此Text Segment、Data Segment都是共享的。如果定义⼀个函数,在各线程中都可以调用；如果定义一个全局变量,在各线程中都可以访问到。 所以，线程强调资源共享并不是一句空话。但由于线程是进程独立的分支，所以即使线程与进程公用地址空间，有些资源也是线程私有的。具体请看下表： 注：虽然线程对于数据区（代码区）也是共享的，但线程只会执行它该执行的一部分。 线程创建在编写创建线程代码之前，我们需要了解以下几点： 1.线程库函数是由POSIX标准定义的,称为POSIX thread或者pthread。在Linux 上线程函数位于libpthread共享库中,因此在编写makefile编译代码时要加上-lpthread选项，编写代码时也要加上pthread.h头文件。 2.这里的pthread.h并不是真正的libpthread共享库，前者只是对后者的一种模拟，相当于高仿。在此库下模拟出的线程叫做“用户级线程”。 3.创建线程函数pthread_create函数表达式： 返回值:成功返回0,失败返回错误号。错误号保存在全局变量errno中,而pthread库的函数都是通过返回值返回错误号,虽然每个线程也都 有 一个errno,但这是为了兼容其它函数接口而提供的,pthread库本身并不使⽤用它,通过返回值返回错误码更加清晰。 明确了这几点，接下来编写代码创建线程。 编写makefile： 编写代码： 代码运行结果： 我们可以看到，两个线程同属pid为9204的一个进程，线程有独立的tid。 注：代码中的tid只在该进程内有效，操作系统并不承认这个tid,只因我们是在模拟库pthread.h中编写的代码。 查看线程除了可以创建线程外，还可以在系统中查看线程。 因为我们模拟出来的线程只在进程运行过程中存在，所以对代码做如下改造。让其死循环，使进程一直在运行当中。这样就便于我们查看系统中的线程。 程序运行效果（当然它是一直在跑的）： 这说明两个线程都属于pid为9430的进程。 指令ps -aL | grep 进程名（一般为可执行文件）可以用来显示正在运行的轻量级进程（线程） 在这张图中，我们需要注意的是： 1.主进程，新进程按照LWP调度2.单进程的LWP和PID一样3.由于资源共享，CPU不会给子进程/线程分配新的时间片，只会将其对应的父进程/进程的时间片分割给他们使用。 我们还可以查看进程信息，可以证明其父进程是bash 这是进程的另一种查看方式：]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程互斥与同步（part4)—终结篇：一股清流—读写锁（rwlock）]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%88part4-%E2%80%94%E7%BB%88%E7%BB%93%E7%AF%87%EF%BC%9A%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81%E2%80%94%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88rwlock%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文将详细介绍linux线程互斥与同步的最后一个概念：读写锁（rwlock） 一股清流为什么把读写锁称为一股清流呢？只因它是一种比较特殊的锁。 那它特殊在哪里呢，我们先来讲一个不悲伤的故事： 王铁锤和李狗蛋是一对好兄弟，铁锤想报答狗蛋上次给他帮的一个大忙，决定中午请他吃饭，李狗蛋欣然答应。 到了中午，铁锤给狗蛋打电话“我到你家楼下了，你下来”，假设狗蛋的回答有两种情况： 1.“我这还有个大Bug没修完，刚有了点头绪，你先在外边等我1个小时，然后咱俩去吃饭。” 2.“行啊，你等我5分钟，我马上就下来。” 对于这两种情况，王铁锤的反应当然也不同。假设对于1，王铁锤听说还要1个小时，就对他说“那我先去旁边的网吧打会LOL，你好了叫我”，于是步行去了网吧开黑。一个小时后，接到李狗蛋电话，两人愉快的去吃饭。 假设对于2，王铁锤听他说马上就下来，掐着表等了5分钟，但李狗蛋还是没下来。就又给他打电话“咋回事啊，不是说5分钟吗”，这时李狗蛋回答“不好意思啊，那啥，我马上就下来，你再等我1分钟”，然后王铁锤又掐着表等了1分钟…，谁知李狗蛋还是没下来。于是又给他打电话“兄弟你行不行啊，咋跟个娘们似的磨磨唧唧”，李狗蛋又回答“实在不好意思，电梯坏了，我走楼梯下来的。你再等30秒，我就下来了啊”。王铁锤不再掐表了，在心里倒数30秒，睁开眼睛李狗蛋已经下来了。两人愉快地去吃饭。 好了，在这个例子中，我们把情况1中王铁锤的表现叫做“挂起等待”，它是需要成本的（去网吧，消耗体力）而把情况2中王铁锤的表现叫做“自旋”：周而复始的做某件事情（打电话） 对应的，我们有挂起等待锁和自旋锁这两个概念。 自旋锁：某线程在临界资源里呆的时间比加锁解锁的时间都短，别的线程就不必挂起等待锁资源。此时就要用自旋锁 （一直询问锁资源，而不必挂起等待） 显然，互斥锁是一种挂起等待锁 那读写锁又是什么呢？ 我们在编写多线程序的时候，有一种情况是十分常见的： 有些公共数据修改的机会比较少，相比较改写，它们读的机会反而高的多。但在读的过程中，往往伴随着查找的操作，中间耗时很长。给这种代码段加锁，会极大地降低我们程序的效率。读写锁就是用来解决这个问题的。 读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑CPU数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。 由读者写者我们就能想到生产者与消费者，那么读者写者模型与生产者消费者模型有什么区别与联系呢？ 其实，两者并没有什么太大的区别，读者写者模型同样遵循321原则，不过有了上面的概念，这里的3种关系显然发生了改变： 写-写：互斥 读-读：没关系 读-写：互斥关系，同步关系（读者优先，写者优先） Code有了读写锁的概念，我们就可以编写代码来实现基于读写锁的读者／写者问题 同样的，在编写代码之前，再了解一下rwlock的接口函数： 其中，pthread_rwlock_t是读写锁类型。 好了，现在来编写代码： step1.创建读者写者线程 step2.创建读者写者，全局变量book（临界资源） step3.创建读写锁并初始化，在函数内部读实现写锁，非阻塞锁 step4：在读者函数和写者函数内部加sleep观察读写锁互斥同步机制1.读者先运行，写者后运行 为了便于观察，将运行结果写入文件rwfile读者先运行，再等待2秒。然后写者得不到锁，非阻塞一直打印读者在读 现象：读者先运行，等待2秒后再解锁。写者在这2秒中得不到锁，非阻塞挂起一直打印读者在读 2.写者先运行，读者后运行 现象：写者先运行，等待2秒后解锁。读者得不到锁，非阻塞挂起一直打印写者在写 另外，在没有用sleep条件下，写者先运行。所以读写锁是写者优先的]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>读写锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程互斥与同步（part3)—解决线程同步的扛把子：单身狗-信号量（ Semaphore）]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%88part3-%E2%80%94%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%89%9B%E6%8A%8A%E5%AD%90%EF%BC%9A%E5%8D%95%E8%BA%AB%E7%8B%97-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88-Semaphore%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文介绍了线程同步的另一个重要概念：信号量（ Semaphore） 一个游戏信号量的概念在进程里也有，它是用来描述临界资源的数目的，关于信号量最重要的就是它的P\V操作。 其中，P操作代表获得资源。V操作代表释放资源。 为了更好的理解信号量和它的PV操作，我们先来玩一个游戏（老司机的微笑&gt;.&lt;） 首先，这个游戏需要两个人。一个是博主，一个是正在阅读的你。 然后泥，场景换到操场跑道上。一个人在前边跑，另一个人在后边追（突然感觉这个游戏有点无聊 -_- |||）。好吧，博主愿意牺牲自己去追你（你是风儿，我是傻。缠缠绵绵到天涯~） 游戏规则是这样滴：慢的人不会超过快的人，快的人也不会把慢的人超一个圈。也就是说，你不会跑的超过博主，博主也不会超出你一个圈。基本上都是博主在后边追（容易吗我。。。） 看到这里，想必你已经发现了问题：1和2这两个边界条件特征完全相同，那么如何区分呢？ 在回答这个问题之前，让我们把上边游戏中的两个人做一个替换：博主变为生产者，你变为消费者。 把上边的环形跑道化为一个个的小格子。生产者在格子里生产（放）数据，消费者在格子里消费（取）数据。这样跑道整体就可以看作一个环形队列（先进先出）。 游戏规则不变，但两个临界条件就变为： 消费者消费的数据等于生产者放了的数据。 生产者生产的数据所占格子数等于消费者消费数据格子数再加上环形队列一圈格子数。 在其他情况下，生产者总是先放数据，消费者总是后取数据的。 替换后，上边的问题就变成：如何判断环形队列是空还是满？ 为了解决这个问题，我们把环形队列里的格子数表示为：blank_sem（它的数目为n），把放的数据数表示为：data_sem。 这样一来，生产者只关心blank_sem的个数。消费者只关心data_sem的个数。data_sem与blank_sem保持同步变化。 所以，环形队列的空或满就可以用生产者和消费者对应的信号量的取值来表示了，生产者每往格子里放一个数据，blank_sem就减1，data_sem就加1。如此一来，判断环形队列空或满的问题也就迎刃而解了。 把格子当作临界资源，也就能深刻理解信号量是如何描述临界资源数目了。 Code有了信号量的概念，我们就可以编写代码用信号量实现线程同步了。 在编写代码之前，我们先来分析几种情况： 1.如何保证生产者线程先运行？ 最开始，生产者和消费者只有生产者有资源（blank），所以只有生产者（blank_sem）的P操作会成功。然后进行data_sem的V操作，唤醒消费者线程进行data_sem的P操作。最后由消费者线程完成blank_sem的V操作。 2.如何保证即使在2个临界条件下程序也能够运行？ 临界条件1（生产者把消费者超了一个环）：生产者一直生产到blank = 0时，因为没有资源（blank_sem = 0），所以它不可能再继续生产,只能挂起等待消费者进行blank_sem的V操作。临界条件2（消费者赶上了生产者）：消费者一直消费到data = 0时，因为没有资源（data_sem = 0），所以它不可能再继续消费，只能挂起等待生产者进行data_sem的V操作。 3.在1和2的前提下，其他情况下消费者一定在生产者的后边。 接下来，我们需要了解关于信号量的接口函数：注：1.在用完semaphore变量之后应该调用sem_destroy()释放与semaphore相关的资源。 调⽤用sem_wait()可以获得资源（P操作）,使semaphore的值减1,如果调用sem_wait()时 semaphore的值已经是0,则挂起等待。如果不希望挂起等待,可以调用sem_trywait() 。 调用 sem_post() 可以释放资源（V操作）,使semaphore 的值加1,同时唤醒挂起等待的线程。 以上函数均包在semaphore.h头文件中 说了这么多，终于要编写代码了（(汗lll￢ω￢) ，还是实现生产者消费者模型，不过交易场所从变为环形队列。 step1：创建消费者生产者线程，用数组模拟环形队列，数组下标取模来形成环形结构 运行程序： 在没有加入信号量之前，两个线程之间没有实现互斥与同步。 step2：加入信号量及其P\V操作实现同步 运行结果： 可以看出信号量完美解决了线程同步问题。 还可以证明前边分析的第2种情况是对的： 在生产函数中加入sleep(2)，让消费者函数先运行，可以得到如下结果：现象是生产一条，消费一条。可见即使消费者先运行，也会因为没有资源而被挂起，让生产者先运行。 还可以证明临界条件下程序的正确运行，以临界条件1为例，在消费函数中加入sleep，可以得到如下结果： The End信号量实现了线程间的互斥与同步。而且它实现互斥是不用加锁的，所以也叫做“无锁同步”，和互斥锁条件变量’cp’比，虽然它是单身狗，但它同样是实现线程同步的“扛把子”。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10min搞定vim配置]]></title>
    <url>%2F10min%E6%90%9E%E5%AE%9Avim%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Vim是linux操作系统的一款非常强大的编辑器，配置Vim就是要让其形成一个像VS一样的IDE集成环境。所以为了能在linux下实现高效编程和开发，Vim的配置是必须要完成的一项任务。 然而，对linux初学者而言，这无非是一个难度不小的挑战。但几乎每个初学者接触linux时，都会被要求配置vim，在网上搜索“vim配置”就会出现很多文章： 网上诸如此类的教程有很多，给出的效果图也很高大上（所有在你看来高大上的东西归根结底就是因为你的无知。）但总是在安装过程中出现很多的问题（对初学者来说是问题）。而这些问题常常难以找出解决方法，只能再点开更多的文章。于是配置vim经常会花费初学者们很多的时间。 所以，本文是一个初学者配置vim后的总结篇，也希望其他的初学者也能快速配置好vim，不再迷茫。 相信我，这一切，只需要10分钟~ 概要本文主要内容有： 1.vim安装 2.vim配置,包括 .vimrc配置 gcc/g++安装 gdb安装 ctags、taglist安装 winmanager安装 2中安装配置的文件和插件是vim最基本的配置。其他插件如有需要可以自行百度安装。 本文将从4个方面来描述安装配置的过程：安装配置文件/插件的概念（what）、为什么要安装（why）、安装过程（how）、安装完成后的效果。 博主使用的是centos虚拟机系统，以下安装均在此系统内进行。 vim安装What？ 文章开头已经说过了，vim是一款编辑器。其实它相当于windows里的记事本一样，能编辑文字。但不同的是它可以通过配置编写运行代码，进行linux下的开发。 但百度过的小伙伴肯定也听过vi这个概念，其实简单点来说，它们都是多模式编辑器，不同的是vim是vi的升级版本。它不仅兼容vi的所有指令，而且还有一些新的特性在里面。例如语法加亮，可视化操作不仅可以在终端运行，也可以运行于x window、 mac os、 windows。 Why？ vim是编写代码的地方，所以当然要先安装它了。否则更别谈配置了。。 How？ 首先cd ~进入用户主工作目录，然后在命令行输入“vi”后双击tab键，可以看到系统中是否安装了vim： 如果出现的内容如上图，说明系统中已经安装了vim，就不必再重复安装了。 如果不是，请点击这里：vim安装，完成后重复上述命令。检查是否安装完成。 如果你的yum install命令失败，那就是你的yum源太老，不支持此条命令。此时可以更新它来进行vim安装。点击这里解决问题：yum更新 效果 安装好vim后，在命令行输入vim test.c新建一个vim文件，此时你的vim编辑器界面是这样的： 然后按下键盘esc键，输入“:（英文模式）”，此时界面左下角出现“:”，表示进入vim的命令模式。输入”wq”（保存退出），即可退出vim编辑器返回到命令行界面。 此时输入ls命令即可看到系统中多了一个test.c文件 .vimrc配置What？ 我们常常在网上看到程序员们各种酷炫拽的代码编辑界面。由于配色方案的不同，各种颜色的代码交织在一起，仿佛置身于一个奇妙的世界。 这是我在网上截的大神图，怎么样，是不是牛逼的惊天地，泣鬼神。。这就是程序员装逼大法之“.vimrc”文件的配置 .vimrc文件是vim的专用配置文件，在里面可以设置各种编辑格式和其他插件的设置。一共有两个： 1.根目录下的.vimrc文件，其设置对所有用户均有效 2.当前用户目录下的.vimrc文件，其设置只对指定（当前）用户有效 而我们要设置的就是当前用户的.vimrc文件 Why？ 配置这个当然是为了装逼啦，不过，其它插件的设置也在.vimrc里。 How？ cd ~进入当前用户的主工作目录，直接输入命令vim .vimrc新建文件。按I键进入insert模式，将下面的基础设置输入你的文件，最后”wq”保存退出即可。 每一项博主都有注释的哦： 博主只演示3个输入效果： 此时，再打开test.c文件，就变成了： 效果 将以上列出的全部配置输入成功后，你的vim就会有如下效果： gcc/g++安装What？ 编译是代码运行成功的前一步，gcc/g++就是linux中的编译器，前者是C语言的编译器，后者是C++的编译器。 Why？ 为了能在linux中实现代码编译，安装他们是势在必行的。 How？ 首先检查自己的系统中有没有安装gcc和g++： 如果没有，直接输入： 1、yum install gcc 2、yum install gcc-c++ 这两条命令就可以安装成功了。 效果 安装好之后，你就可以编写程序并运行了。打开test.c文件，输入源程序，保存退出： 紧接着用gcc进行编译运行： gdb安装gdb是linux的代码调试器，关于其安装可以用以下命令： yum install gdb（事实上，yum就是linux的安装命令） 直接安装，也可以点击这里：linux下gdb的安装方法 进行安装 至于其效果，在这里就不演示了，调试命令需要大家自己练习掌握。。 ctags、taglist安装What？ TagList插件是一款基于ctags，在vim代码窗口旁以分割窗口形式显示当前的代码结构概览，增加代码浏览的便利程度的vim插件。所以，要安装taglist就得先安装ctags. Why？ 此插件可以方便代码浏览，所以下载百利而无一害 How？ 首先下载ctags： 直接在命令行输入：yum install ctags即可安装 最后用unzip命令解压安装完成。 然后下载taglist: 这里是官方下载地址：http://www.vim.org/scripts/script.php?script_id=273 下载taglist_xx.zip ，用unzip命令解压完成。这里是linux各种后缀压缩文件的解压方法： 用unzip命令解压后，将解压出来的doc的内容放到～/.vim/doc, 将 解压出来的plugin下的内容拷贝到～/.vim/plugin （此举是为了访问文件安全），如图： 最后，打开.vimrc文件，在里面输入如下几行（红框内），保存退出： 当然，其他的配置可以选择输入 效果 下载好之后，打开test.c文件，就会有如下效果： 右边的main函数高亮表示当前在main函数的编辑区内。 winmanager安装What？ winmanager是vim中的文件资源管理器。 Why？ 有了它，我们可以看到当前工作目录下的文件。便于操作 How？ winmanager的安装和taglist类似。 这里是下载的官方链接： http://www.vim.org/scripts/script.php?script_id=95 建议下载winmanager.zip，2.X版本以上的 下载安装包后用unzip命令解压，同样将解压出来的doc的内容放到～/.vim/doc, 将 解压出来的plugin下的内容拷贝到～/.vim/plugin 。 这样，加上先前的taglist，.vim目录下就会有如下内容： 好了，接下来同样在.vimrc文件里加入下面几句： 这样在vim的正常模式下按F2就可以直接打开winmanager，再次按F2就可以关闭它。 如果你刚才将taglist图中的所有配置全输入进去，此时你打开test.c文件，按F2打开winmanager的时候，效果是这样的： 但这样在命令行输入多次“:q”才能退出vim，而且窗口太多有点烦。 当然，你也可以通过更改.vimrc配置来改变taglist和winmanager两个窗口的位置： 更改一：把winmanager作为独立的窗口，和taglist一左一右 效果： 这样虽然窗口少了一点，但退出时还是要在命令行输入多次“:q” 所以博主推荐这种做法，把taglist的自动打开屏蔽掉，这样按F2就可以一次性打开/关闭2个窗口。退出时也不麻烦： 效果 下载好之后，就会有如下效果： 其中FileList界面就是winmanager显示出的效果，怎么样，是不是有点酷炫拽的意思了。图中点击node_p就可以直接跳转到它的定义处。所以你知道taglist是实现代码跳转的了吧。 同样在FileList中点击makefile就可以直接跳转到它的界面，想必你也知道winmanager文件资源管理器的深刻含义了。 The End当然，除了上面讲的插件。还有很多的vim插件，但对于小白来说，这些插件已经足够了。如果想在安装别的插件，可以自行百度。而.vimrc的配置也绝不是文中列举的那些，还有很多个性化的配置方案。有余力者也可以百度下载。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用字符串数组实现一个简单的文本编辑器基础]]></title>
    <url>%2F%E5%88%A9%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[功能： 接受多行输入，输入空行退出。并将输入的所有内容打印在屏幕上。 代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#define STRNUM 100#define STRLEN 100char text[STRNUM][STRLEN];int main()&#123; int line,strnum,Strlen; printf("tips: enter a spaceline to exit\n"); printf("---------------------------------\n"); //receive for (line=0; line &lt; STRNUM; line++) &#123; printf("line%d: ", line); gets_s(text[line]); if (!*text[line]) &#123; break; &#125; &#125; //printf for (strnum = 0; strnum &lt; line; strnum++) &#123; for (Strlen = 0; text[strnum][Strlen]; Strlen++) &#123; putchar(text[strnum][Strlen]); &#125; putchar('\n'); &#125; system("pause"); return 0;&#125; 效果：]]></content>
      <categories>
        <category>C/C++基础</category>
      </categories>
      <tags>
        <tag>字符串数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用arp.sh脚本文件抓取局域网内所有主机的IP和MAC地址]]></title>
    <url>%2F%E7%94%A8arp-sh%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%8A%93%E5%8F%96%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E6%89%80%E6%9C%89%E4%B8%BB%E6%9C%BA%E7%9A%84IP%E5%92%8CMAC%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[本篇博文主要介绍以下内容： 1. ARP协议简介 2. 小程序：抓取局域网内所有主机的IP和MAC地址 ARP协议 Concept先来一波文字(oﾟ▽ﾟ)o ： 在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号。却不知道目的主机的硬件地址（MAC地址）,而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。 因此在通讯前必须获得目的主机的MAC地址，ARP协议就起到这个作用 它的工作步骤如下： Step1：源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”,并将这个请求广播到本地网段(以太⽹网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播) Step2：目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符；则发送一个ARP应答数据包给源主机,将⾃己的硬件地址填写在应答包中。 注：每台主机都维护一个ARP缓存表,可以用arp -a命令查看： 为了降低对内存的占用，缓存表中的表项都有过期时间(一 般为20分钟)，如果20分钟内没有再次使用某个表项，则该表项失效。下次还要发ARP请求来获得目的主机的硬件地址。 所以ARP协议的作用就是在局域网内实现从IP地址到MAC地址的转换 ARP报文格式ARP数据报的格式如下所示: 图中： 源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现⼀次，对于链路层为以太网的情况是多余的。但如果链路层是其它类型的网络则有可能是必要的。 硬件类型指链路层网络类型，1为以太网。协议类型指要转换的地址类型，0x0800为IP地址。后面两个地址长度对于以太网地址和IP地址分别为6和4(字节)。 op字段为1表示ARP请求,op字段 2表示ARP应答。 在ARP协议实际工作中，先关心OP字段是APR请求1还是应答2，然后是目的IP地址/发送端IP地址。最后发送前边的数据报。 #Code ## 下面编写脚本文件arp.sh实现对局域网内所有主机IP和MAC地址的抓取。 Step1：touch arp.sh脚本文件，用vim编辑完成后，更改权限至可执行文件 Step2：编辑源程序 以下为源程序： 注：里边的ip_head是博主虚拟机的所在局域网的网络号，读者想要抓取，就要更改其为自己所在局域网的ip地址，在命令行输入ifconfig命令就可以看到： Step3：sh arp.sh运行程序抓取到了局域网内所有应答成功主机的IP和MAC地址 运行程序： 得到以下结果： 其中，2是博主手机的ip和MAC地址： 这个在手机设置里的关于手机现象就可以看到。 1是博主电脑的ip和MAC地址： 这个在wimdows里打开cmd窗口输入“ipconfig /all”命令就可以看到： Expand： tcpdump&amp;nmap 其实，上边的方法是有很大弊端的，现在网络加密技术发达，简单的抓包的方法已经不能满足网络分析的需求，基于此，Linux提供了抓包工具tcpdump和namp。 1.tcpdump1. What？ tcpdump是一个用于截取网络分组，并输出分组内容的工具。 tcpdump凭借强大的功能和灵活的截取策略，使其成为类UNIX系统下用于网络分析和问题排查的首选工具。它提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。 在命令行输入tcpdump -h就可以查看它的基本语法： 上边显示了各种选项的含义。 tcpdump存在于基本的Linux系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。 2.How？博主对tcpdump没有深入的了解，也没有找到优秀的文章讲解，感兴趣的小伙伴可以自行百度٩(๑&gt;◡&lt;๑)۶ 2.nmapwhat &amp; how这个工具是需要下载的，想了解的小伙伴可以自己百度。。 Other 虚拟机联网的四种方式 博主刚开始运行程序的时候并没有成功，是因为没有把虚拟机的联网方式改为桥接模式，这样虚拟机会共享其所在电脑主机的ip地址。所以不能抓取，解决方法就是把联网方式改为桥接模式： 打开虚拟机的设置界面，在网络适配选项选中桥接模式。完成后重启虚拟机再运行程序就不会有问题了 事实上，虚拟机的联网方式常用的是就是图中前两种形式，主要看你的上网环境。 如果你是外网环境，建议你使用NAT模式，此时虚拟机和客户机共享ip地址上网。就出现了抓取不到的问题。如果你是局域网环境建议使用桥接，就是第二种模式，该模式下虚拟机和你局域网中的其他实体计算机在网络状态上完全一样，你完全可以把他当作是局域网中的另一台实体计算机。 至于剩下的两种就不怎么常用了，读者有兴趣的话可以自己找资料查下，网上有很多。 外网和内网 至于桥接模式和NAT模式所涉及的外网和内网的概念，博主也找到了一篇不错的文章了解了一下，感兴趣的小伙伴请戳这里： 关于内网和外网区别]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>IP</tag>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒懂UDP协议&TCP协议]]></title>
    <url>%2F%E5%B0%8F%E7%99%BD%E7%9A%84%E7%A6%8F%E9%9F%B3%E2%80%94%E7%A7%92%E6%87%82UDP%E5%8D%8F%E8%AE%AE-TCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了UDP\TCP协议的基础知识，主要内容有： UDP\TCP协议在TCP/IP协议栈中的位置和作用 UDP\TCP协议数据段格式 TCP协议如何保证数据传输的可靠性 TCP/IP协议栈 TCP/IP⽹网络协议栈分为应⽤用层(Application)、传输层(Transport)、⽹网络层(Network)和链路层 (Link)四层： 其中，传输层及其以下的机制由内核提供，应用层由用户进程提供。 应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节。从而将数据从一台计算机通过⼀定的路径发送到另一台计算机。 这就是两台计算机通过TCP/IP协议栈进行通讯的过程，当然还有很多细节。 此过程中，TCP&amp;UDP协议在传输层发挥作用。上层协议根据TCP数据段首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程，完成数据传输。 TCP协议一种面向连接的、可靠的协议。 有点像打电话。双方拿起电话互通身份之后就建立了连接，然后说话就行了。这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。 也就是说TCP传输的双方需要⾸先建立连接，之后由TCP协议保证数据收发的可靠性。丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流。通讯之后关闭连接。 UDP协议 UDP协议不面向连接，也不保证可靠性。 有点像寄信，写好信放到邮筒里。既不能保证信件在邮递过程中不会丢失，也不能保证信件是按顺序寄到目的地的。 所以，使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。 数据段格式 不同的协议层对数据包有不同的称谓，在传输层叫做段(segment)，在网络层叫做数据报(datagram)。在链路层叫做帧(frame)。 接下来详细介绍UDP和TCP协议的数据段格式。 UDP协议 举个例子，分析一帧基于UDP的TFTP协议帧： 源端口号0x05d4(1492)是客户端的端口号，目的端口号0x0045(69)是TFTP服务的well-known端口号。 UDP报长度为0x003f，即63字节。包括UDP首部和UDP层payload的长度。 UDP首部和UDP层payload的校验和为0xac40。 一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器。客户端主动发起请求 (上面的例子就是客户端发起的请求帧)。而服务器被动地等待、接收和应答请求。 客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程。 前面提过，UDP协议不⾯向连接，也不保证传输的可靠性。这一点主要体现在： 1. 无法判别数据的失败传输 发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。 2. 无法保证数据接收顺序 接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。 3. 丢包问题 通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快。就会丢失数据包,UDP协议层并不报告这种错误。 因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案。 例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。 例如，基于UDP的TFTP 协议一般只用于传送小文件，而基于tcp的协议适⽤于各种文件的传输。 TCP协议下⾯面 看TCP协议如何⽤用⾯面向连接的服务来代替应⽤用程序解决传输的可靠性问 题。 和UDP协议一样，TCP的数据段中也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。 32位序号、32位确认序号、窗口大小均是保证数据传输可靠性的机制。 4位首部长度表示TCP协议头的长度，以4字节为单位。因此TCP协议头最长可以是4x15=60字节，如果没有选项字段,TCP协议头最短20字节。 URG、ACK、PSH、RST、SYN、FIN是六个控制位，用于保证传输可靠性。 16位检验和将TCP协议头和数据都也用于保证传输可靠性。 TCP协议的可靠性 上边说过，TCP保证数据传输的可靠性，那它是怎么保证的呢？故事很长，你准备好听我说了么&lt;(▰˘◡˘▰)&gt; 1. TCP是面向连接的，并且是全双工的 事实上，TCP协议为应用层提供了全双工(full-duplex)的服务，双方都可以主动甚至同时给对方发送数据。 如果通讯过程只能采用一问一答的方式，收和发两个方向不能同时传输，在同一时间只允许一个方向的数据传输,则称为’’半双工(half-duplex)’’ 2. TCP基于请求应答机制 在数据传输时，请求方请求数据时附上自己报文序号，应答方在应答时附上确认序号，防止数据丢失。所以最新一条数据无法保证可靠性，只有确认过的消息才能保证 3. 丢包重查 基于请求应答机制，数据丢失可以及时发现，从而进行丢包重查。 4. 保证数据按序到达 同样基于请求应答机制，数据可以按时到达。 5. 6个控制位 上边TCP协议的数据段中，给出了6个控制位，它们也保证了数据传输的可靠性。具体待博主后续介绍。 6. 定时器 TCP协议维护了各种定时器，用来保证双方通信的可靠性。 比如防止过多闲置链接的“保活定时器”，还有防止接收方缓冲区虽满，但迟迟不读取数据，导致占用链接资源的“超时重查定时器”（超时后将此链接重置（关闭））。 还有很多定时器，博主将在后续博文中总结，敬请期待。 7. 流量控制 数据传输中，发送与接收速度不一致时，可以扔掉多余数据。因为有丢包重查。但多次丢包重查操作也会浪费资源。所以为了协调速度，应该以缓冲区大小为标志。每次数据传输时接收方将自己的缓冲区大小告知发送方，防止其在接收缓冲区已满的情况下再发送数据。 这就是流量控制。 TCP数据段中的——16位窗口大小就是这里的接收缓冲区大小，它也叫做滑动窗口。滑动窗口的大小永远是自己能接收数据的缓冲区大小。这样就保证了数据进可能少的丢包。 数据通讯中滑动窗口如何发挥作用，博主也会在后续博文中详细介绍。小伙伴们不要心急哟~ 8. 网络拥堵避免算法 除了滑动窗口，TCP还实现了网络拥堵避免算法，进一步避免了大量数据丢包。 至于算法是怎么样的，博主就不在这里介绍了，感兴趣的小伙伴可以自行百度ヾ(◍°∇°◍)ﾉﾞ 9. TCP是面向连接的 TCP的面向连接主要体现在3次握手、4次挥手上。这可是个很重要的问题，当然要另写博文详细介绍啦。我们再约~ 注意：虽说TCP协议与UDP协议相比，保证了数据传输的可靠性，但两者没有谁好谁坏的问题，只是适用场景不同。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>UDP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些基础的语法练习题（1）]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[折半查找12345678910111213141516171819202122232425262728293031323334353637383940414243444546int BinSearch(int array[], const int x, int size)&#123;int begin = 0;int last = size - 1;if (begin &gt; last)&#123; cout &lt;&lt; "没找到！"; return -1;&#125;while (begin&lt;=last)&#123; int mid = (last + begin) / 2; if (array[mid] == x) &#123; cout &lt;&lt; "找到啦，位置是："; return mid+1; &#125; else if (array[mid] &lt; x) &#123; begin = mid + 1; &#125; else &#123; last = mid - 1; &#125;&#125;cout &lt;&lt; "没找到！";return -1;&#125;int main()&#123;int tar[] = &#123; 2,4,6,8,10,12,14,16 &#125;;int num = 0;while (1)&#123; cout &lt;&lt; "输入你要查找的数字："; cin &gt;&gt; num; int result = BinSearch(tar, num, 8); cout &lt;&lt; result &lt;&lt; endl;&#125;system("pause");&#125; 小球弹跳一个球从100米的高度自由落下，每次落地后反跳回原高度的一半。再落下，再反弹。求第10次落地时，共经过多少米，第10次反弹多高？ 分析：以反弹次数作为循环条件，反弹高度很容易求。但要注意第一次反弹后再落地时已经是小球第2次落地了。所以要注意小球反弹的次数和落地的次数并不一样，第10次落地在第10次弹跳之前，所以只能加9次。 12345678910111213 float sum = 100;float height = 100;int times;//反弹次数for (times = 1; times&lt;11; times++)&#123; height /= 2;//反弹高度 if (times &lt; 10) &#123; sum += 2 * height;//反弹后落地经过的长度 &#125;&#125;cout &lt;&lt; "height=" &lt;&lt; height &lt;&lt; endl;cout &lt;&lt; "sum=" &lt;&lt; sum&lt;&lt; endl; 字符汇聚int main() { char tar[] = &quot;************&quot;; char src[] = &quot;hello world!&quot;; int i = 0; int j = 0; printf(&quot;%s\n&quot;, tar); for (i = 0, j = strlen(tar) - 1; i &lt; j; i++, j--) { tar[i] = src[i]; tar[j] = src[j]; Sleep(1000); printf(&quot;%s\n&quot;, tar); } system(&quot;pause&quot;); } 登录系统1234567891011121314151617181920212223242526272829int main()&#123;char pass[] = "hello";char enter[] = "";for (int i = 1; i &lt; 4; i++)&#123; cout &lt;&lt; "请输入密码："; cin &gt;&gt; enter; if (strcmp(enter,pass)==0) &#123; cout &lt;&lt; "密码正确！" &lt;&lt; endl; break; &#125; else &#123; if (i &lt; 3) &#123; cout &lt;&lt; "密码错误，你还有" &lt;&lt; 3 - i &lt;&lt; "次机会" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "密码错误，登录失败！" &lt;&lt; endl; &#125; &#125;&#125;system("pause");&#125; 猜数字游戏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 void menu()&#123;cout &lt;&lt; "********************************" &lt;&lt; endl;cout &lt;&lt; "猜数字游戏： 1-&gt;开始 0-&gt;退出" &lt;&lt; endl;cout &lt;&lt; "********************************" &lt;&lt; endl;&#125;int main()&#123;int choice = 1;while (choice)&#123; menu(); cout &lt;&lt; "输入选项："; cin &gt;&gt; choice; switch (choice) &#123; case 1: &#123; cout &lt;&lt; "~游戏开始~" &lt;&lt; endl; int random = rand() % 100; int input = 0; while (1) &#123; cout &lt;&lt; "输入你猜的数："; cin &gt;&gt; input; if (input == random) &#123; cout &lt;&lt; "你猜对了!" &lt;&lt; endl; break; &#125; else if (input &lt; random) &#123; cout &lt;&lt; "你猜小了~" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "你猜大了~" &lt;&lt; endl; &#125; &#125; &#125; case 0: exit(1); default: cout &lt;&lt; "没有此选项，请重新输入！" &lt;&lt; endl; break; &#125;&#125;system("pause");return 0;&#125; 猴子吃桃从前有只小猴子，摘了一大推桃子。第一天吃了一半，觉得不过瘾又吃了一个。第二天又吃了第一天剩下桃子的一半，还是多吃了一个。以后每天都吃了一半零一个桃子。到了第10天，只剩下了一个桃子，那么小猴子最开始摘了多少桃子？ 分析：因为每一天都吃了一半零一个桃子，多吃的那一个桃子是另一半的其中之一。所以第10天的桃子加1就是第9天桃子的一半，再乘以2就是第9天桃子的全部数量。以此类推就可以求出所有的桃子数量。 12345678910111213int main()&#123; int sum = 0; int num = 1; for (int i = 9; i&gt;0; i--) &#123; sum = (num + 1) * 2;//比前一天的一半少一个 num = sum; &#125; cout &lt;&lt; "sum=" &lt;&lt; sum &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>C/C++基础</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归求解1到100求和]]></title>
    <url>%2F%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A31%E5%88%B0100%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[递归求解1到100的和是一个常见面试题。 思想： 思考一下，从1加到100可以分解成： 1+（2加到100的和） 1+2+（3加到100的和） 1+2+3+（4加到100的和） …… 怎么样，这样是不是有点递归的味道了？递归的出口就是1。 所以，可以编写如下代码： 代码： 123456789int count(int n)&#123; if (n &gt; 1) &#123; return n + count(n - 1); &#125; else return 1;&#125; 这样，不仅可以求1到100的和，还可以求任意区间数字的和。只要改变递归出口和上限即可。]]></content>
      <categories>
        <category>笔试面试题</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于闰年，你不知道的那些事]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E9%97%B0%E5%B9%B4%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[“四年一闰，百年不闰，四百年再闰”。你知道为什么吗？ 判断某一年是否是闰年几乎是所有编程语言的基础练习题之一，而我们必然也熟知其规则： 整除但4不能整除100 整除100又能整除400 这就是俗语中的“四年一闰，百年不闰，四百年再润”，我们当然可以根据这个规则编写程序判断闰年，但你知道为什么这样规定闰年的算法么？ 事实上，闰年是为了弥补因人为历法规定，造成的年度天数与地球实际公转周期的时间差而设立的。所以闰年有366天。 那么具体是怎么弥补的呢？ 我们知道，平年一年只有365天，而实际上地球绕太阳的公转周期为365天5小时48分46秒。即一回归年。所以公历的每一年都比回归年短0.2422天，四年累计起来，共短0.9688天。 大概就是一天，所以为了弥补这一天的时间差。给2月加上1天，就有了闰年。这样一来，每四年里就有一个闰年，3个平年。这就是四年一闰。 那么百年不闰，四百年再闰又是怎么回事呢？ 是这样的，刚才说四年累计起来的时间差只有0.9688天，这比我们给闰年增加的一天还少0.0312天，所以每四年就会多出0.0312天。这样400年后，就会比实际天数多出3.12天。所以我们必须在这400年中少设3个闰年。这样公历年的平均长度与回归年就近似了。 那这3个闰年怎么少呢？ 很简单，给百年除以400即可，比如2000-2400这400年： 2000/400=5 2100/400=5.25 2200/400=5.5 2300/400=5.75 2400/400=6 可以发现，正好有3个不能整除的整百年。所以规定年份是整百数的必须是400的倍数才是闰年。这就是百年不闰，四百年才闰的规定。 你明白了吗？ 当然，根据规则，我们就可以编写代码判断了： int main() { int year; cin &gt;&gt; year; if (year % 4 == 0) { if (year % 100 != 0)//1. 能整除4，不能整除100 { cout &lt;&lt; "是闰年\n" &lt;&lt; endl; } else if ((year % 100==0) &amp;&amp; (year % 400==0))//2. 能整除100， 又能整除400 { cout &lt;&lt; "是闰年\n" &lt;&lt; endl; } else//其它情况不是闰年 { cout &lt;&lt; "不是闰年\n" &lt;&lt; endl; } } else//不能整除4就不是闰年 { cout &lt;&lt; "不是闰年\n" &lt;&lt; endl; } system("pause"); }]]></content>
      <categories>
        <category>C/C++基础</category>
      </categories>
      <tags>
        <tag>闰年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程互斥与同步（part2)—互斥锁（Mutex）的cp：条件变量(Condition Variable)]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%88part2%EF%BC%89%E2%80%94%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutex%EF%BC%89%E7%9A%84cp%EF%BC%9A%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-Condition-Variable%2F</url>
    <content type="text"><![CDATA[条件变量（Condition Variable）和互斥锁（Mutex）的“cp”关系有句话叫“既生瑜，何生亮”，虽说互斥锁和条件变量都是为了维持线程间的互斥与同步。但他们可不是’瑜’和’亮’的关系。确切的说，他们俩是一对‘cp’。 首先，我们想象这样一个场景，有两个人，一个往盘子里放苹果；另一个从盘子中取苹果。 如果我们将盘子看作临界资源，把这两个人当作两个线程。加入互斥锁后，就形成了对盘子的互斥访问。如果一个人拿到锁进入临界区放苹果，此时另一个人也来申请锁想拿苹果。那么这个人代表的线程就会被阻塞。在第一个人拿锁和解锁之前的整个过程中，第二个人只能一直申请访问互斥锁，直到第一个人解开锁。 线程进入临界区之前要先访问互斥锁，像上述例子中由于两个人的优先级不同，优先级高的线程不断重复“拿锁-进入临界区-放锁”的过程，且不做实质性的工作（占着茅坑不拉屎）。导致优先级低的线程得不到时间片来访问互斥锁。这样就会形成线程的“饥饿”问题。为了解决这种问题，我们要保证对互斥锁的访问按某种顺序进行；使线程之间协同合作，这就是线程同步。 条件变量就是保证线程同步的一剂良药。 它提供了一种通知机制：在优先级高的线程放锁后立即通知别的线程取锁，若优先级高的线程想再次申请锁，只能在条件变量上挂起等待，这样就杜绝了优先级高的线程长时间霸占锁资源，实现线程间同步。其实质是用变量的形式来表示当前条件是否成熟，标志资源状态。从而方便线程之间协作运行。 有了条件变量，上边的例子就会变成这样： 总结一下：单纯的互斥锁用于短期锁定，主要是用来保证线程对临界区的互斥进入。而条件变量则用于线程的长期等待，直至所等待的资源成为可用的资源。 所以，一个Condition Variable总是和一个Mutex搭配使用（地表最强cp）。 Code（代码举例）知道了条件变量的概念，下面我们编写代码深入了解其作用。 首先了解一下条件变量主要的接口函数 一个线程可以调用 pthread_cond_wait函数在一个Condition Variable上阻塞等待,这个函数做以下三步操作: 释放Mutex 阻塞等待 当被唤醒时,重新获得Mutex并返回 具体唤醒多少线程与问题规模有关。一个线程可以调用 pthread_cond_signal唤醒在某个Condition Variable上等待的另一个线程,也可以调用 pthread_cond_broadcast唤醒在这个Condition Variable上等待的所有线程。 代码目的：实现基于单链表模式的生产者-消费者模型利用生产者-消费者模型和链表结构，生产者生产一个结点串在链表的表头上,消费者从表头取走结点。 科普时间：生产者与消费者模型？ 知道了这些基本概念，现在我们来编写代码： step1: 构建交易场所（临界资源）：链表 在编写链表基本操作Init,PushHead,PopHead,Destory函数后，运行程序： step2:创建生产消费者：2个线程 step3:保证互斥与同步：加入互斥锁保证线程之间的互斥访问 运行程序： 可以看到，虽然实现了互斥，但生产与消费并非间接进行，所以现象是长时间一直在生产，或一直在消费。这与实际情况不符。 step4:加入条件变量实现线程同步 我们对代码进行改造，如果生产者生产慢（sleep(1)），让消费者一直消费，且是无效消费（-1）， 就会出现下边的情况： 这是因为虽然消费者是无效消费，但它一直占用锁。导致生产者没有时间生产。这是由于对交易场所的状态一无所知导致的 所以由开始对条件变量作用的分析，结合刚才的结果，可以知道消费者也可能像优先级高的线程那样，有“拿锁-进入临界区（取数据）-放锁”的不断重复过程，但消费者将链表数据取完后就不应该再取了，所以要用条件变量来表示交易场所的状态（链表满或不满）。 所以在程序中加入条件变量，在生产函数里加入唤醒函数，消费函数里加入等待函数： 程序运行效果如下： 可以看到，尽管消费函数先运行只，但它在判断链表为空后只能在条件变量上挂起等待。只有在生产者生产后消费者才能消费，且生产一条，消费一条。 注：这里的pthread_cond_wait函数参数中的锁并非表示线程抱着锁挂起，而是释放锁之后再挂起。 step4: 另外，如果等待函数调用失败，还是会非法消费，所以加入检测：把 if -&gt; while 至此，条件变量结束。 The End其实仔细想想，上边的程序实际上是实现了一个栈，它符合后进先出的原则。 而且上述程序是生产1条，消费1条。且是在生产里边唤醒消费。其实我们还可以实现生产多条，通知1次的机制，只需要在生产函数里加入计数器即可。 另外，还可以实现生产者与消费者的互相通知唤醒机制，只需在程序中再加入一个条件变量，然后在消费函数里加入它的唤醒函数。 虽然 ‘cp’搭配，干活不累，但有时候单身狗的力量更强大（诶呀，好像剧透了&gt;~&lt;），好吧。本系列下一篇要介绍的就是“单身狗”—信号量的故事。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>条件变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO概念&5种IO模型介绍]]></title>
    <url>%2FIO%E6%A6%82%E5%BF%B5-5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[本文介绍了IO概念和5种IO模型，希望能以最轻松的方式让大家理解这两个知识 ٩(๑&gt;◡&lt;๑)۶ Concept IO叫做输入输出，我们可以将IO理解为两步： 等待IO事件就绪 数据就绪后进行真正意义上的IO（真正的数据搬迁） 所以，IO的过程一是等，然后才是输入输出。 进而，我们可以得到评价IO是否高效的标准： 在IO过程中“等”的比重越小的性能越好，越大的性能越低。 IO中有两个重要的函数：read&amp;write 他们也有两个功能： 等 获取/写数据 等就是不能读和写，也就是写/读条件不就绪，即发送/接收缓冲区没有被写满，所以读写事件是否就绪通常要与文件描述符相关。 5种IO模型 1.一个故事 先给大家讲一个钓鱼的故事٩(๑&gt;◡&lt;๑)۶ ~风和日丽的一天，张铁锤拿着鱼竿和小板凳，提着桶，来到小河边钓鱼。~ 他先给鱼竿上放好鱼饵，然后就坐在自己的小板凳上，眼睛一直瞪着鱼竿的尽头。等到鱼上钩后，自己收竿把鱼放在桶里。 不一会，李狗蛋也来了。 他也和王铁锤一样，上好鱼饵之后就等鱼上钩。但他的做法是一边玩手机，一边瞄着鱼竿是否有动静，还不时的和王铁锤搭讪，但王铁锤并不理他，因为他在一动不动的盯着鱼竿，不能分心。 又过了一会，赵二毛也来凑热闹了， 但他多拿了一样东西———铃铛，他把铃铛系在鱼竿上，然后坐在小板凳上，拿出了一本《C和指针》看起了书，这样铃铛一响就直接收竿。嗯，文化人就是不一样。 今天钓鱼的人真不少，刘翠花也过来了， 但她放了个大招，直接拿了100多只鱼竿，全固定在岸边。这样几乎不用等，水池边全是她收竿的身影。不一会儿，就钓了好几桶鱼。 王老五看见这么多人钓鱼，顿时兴致也来了，但人家是老板，还有事要做。 于是吩咐司机让他去钓鱼，钓到了鱼就打电话通知他。只能说，有钱人就是不一样。 好了，我们的故事就讲到这里。 其实，钓鱼的过程和IO非常类似，要先等鱼上钩，然后才真正开始钓鱼。所以，上边的5个人实际上就对应了5种IO模型。 2. 5种IO模型 用这种讲故事的方式来介绍5种IO模型还是太口语化了，还是让我们严肃一点吧 (｡◕ˇ∀ˇ◕) 1. 阻塞IO 对于王铁锤，他一直看着鱼竿，自己等，自己钓，而且等的过程中不做其他的事。这就是阻塞IO： 阻塞式等待IO事件，在等的过程中不能做其他事。 2. 非阻塞IO 对于李狗蛋，他也是自己等，自己钓。但他并不是一直盯着鱼竿，而是时刻检测钓鱼事件是否就绪，没有就做其他的事（玩手机、搭讪）。这就是非阻塞IO： 非阻塞等待，不断检测IO事件是否就绪。没有就绪就可以做其他事。 3. 信号驱动IO 对于赵二毛，他将钓鱼事件是否就绪的信息转移到铃铛上，不用自己检测事件就绪，只需要将铃铛作为信号通知方式。这就是信号驱动IO： linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。 4. IO复用/多路转接IO对于刘翠花，她也是自己等，自己钓。但可以同时等待多个鱼上钩事件。这样她钓到鱼的概率就很大，等的时间短，效率明显比其他人高。这就是多路转接IO： linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数 5. 异步IO对于王老五（老板），他并没有经过等的过程，只需要发起事件（让司机钓鱼），然后享受结果。这就是异步IO： linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。 3. 区别与联系 前4种模型都有等和IO两个阶段，并将数据从内核拷贝到调用者的缓冲区，自己等，自己进行数据搬迁。所以统称为同步IO。 与第5种异步IO相区分。 注：这里同步/异步的概念与进程&amp;线程中的概念不同，不同的背景下应该有不同的理解。 The End本文通过一个小故事介绍了5种IO模型，希望能让大家更好的理解这几种IO模型的概念和区别。 告辞。。。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络通信模型总结：OSI&TCP/IP]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93%EF%BC%9AOSI-TCP-IP%2F</url>
    <content type="text"><![CDATA[为什么需要网络通信模型？在第三代网络出现以前，网络是无法实现不同厂家设备互连的。早期，各厂家为了霸占市场，各厂家采用自己独特的技术并开发了自己的网络体系结构。 而不同的网络体系结构是无法互连的，所以不同厂家的设备无法达到互连，即使是同一家产品在不同时期也是无法达到互连的，这样就阻碍了大范围网络的发展。 为了实现网络大范围的发展和不同厂家设备的互连，网络模型应运而生。 说白了，网络模型的出现使得计算机之间可以更好的进行信息交换。 OSI七层参考模型为了实现网络大范围的发展和不同厂家设备的互连，1977年国际标准化组织ISO（International Organization for Standardization,ISO）提出一个标准框架——OSI（Open System Interconnection/ Reference Model,开放系统互连参考模型）共七层。 结构图示OSI模型把开放系统的通信功能划分为七个层次，从邻接物理媒体的层次开始，分别赋于1，2，……7层的顺序编号，相应地称之为： 物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。 每一层的功能是独立的。它利用其下一层提供的服务并为其上一层提供服务，而与其他层的具体实现无关。这里所谓的”服务”就是下一层向上一层提供的通信功能和层之间的会话规定，一般用通信原语实现。两个开放系统中的同等层之间的通信规则和约定称之为协议。通常把1~4层协议称为下层协议，5~7层协议称为上层协议： 像不像葫芦娃：葫芦娃，葫芦娃，一根藤上七个瓜。风吹雨打都不怕，啦，啦啦啦~ 各层详细说明如下表： 层数 作用 相关协议 相关设备 应用层 实现应用进程之间的信息交换，根据相应协议提供通信服务 HTTP\FTP\SMTPTELNET\SSH 应用程序，终端 表示层 把数据转换为能与接收者的系统格式兼容并适合传输的格式。 LPP/XDP 终端 会话层 负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。 SSL/TLS 终端 传输层 接收上层数据并交给网络层，保证数据传输可靠 UDP/TCP 终端 网络层 控制子网运行，将数据进行逻辑编址，路由选择，分组传输 IP 终端 数据链路层 物理寻址，将原始比特流变为逻辑传输线路。负责网络寻址、错误侦测（CRC）和改错 SLE/RRTP 网卡/网桥 物理层 为设备之间的数据通信提供传输媒体及互连设备，为比特流传输提供可靠的环境。提供有关同步和全双工比特流在物理媒体上的传输手段 RS232C、RS449/422/423、V.24/X.21、X.21bis 针脚/电压/线缆规范/集线器/中继器/网卡/主机适配器/空明线/平衡电缆/光纤/无线信道 网上有张大图，比较高能： TCP/IP四层参考模型 当无线网络wifi和卫星出现以后，现有的协议在和它们相连的时候出现了问题，所以需要一种新的参考体系结构。这个体系结构在它的两个主要协议出现以后，被称为TCP/IP参考模型 结构图示TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下层所提供的网络来完成自己的需求。这4层分别为： 各层详细说明 层数 作用 相关协议 应用层 应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务 HTTP\FTP、SMTP 传输层 传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性 TCP/UDP 网络互联层 网际互连层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。 IP/ICMP/IGMP/ARP 网络接入层 网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。 —— 区别 相同点 SI参考模型和TCP/IP参考模型都采用了层次结构的概念 都能够提供面向连接和无连接两种通信服务机制 不同点 OSI是七层模型，TCP/IP是四层结构 对可靠性要求不同（TCP/IP更高） OSI模型是在协议开发前设计的, 具有通用性.TCP/IP是先有协议集然后建立模型, 不适用于非TCP/IP网络. 实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>IP</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试工具调研]]></title>
    <url>%2F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[测试工具测试管理工具TestLinkgitTestDirector（TD，基于web）缺陷跟踪工具BugzillajiraMantisBugFree软件自动化测试工具web测试web自动化测试工具：seleniumweb性能/压力测试工具：LoadRunner jmeterweb安全性测试工具：AppScanapp自动化工具appiumMonkeyMonkey Runneruiautomator手机端测试Robotium（Android,开源）Instruments （IOS, 开源）白盒测试（单元测试）工具gtestjtest黑盒测试：Bugtags持续集成工具：jenkins其他QTP(quicktest Professional)代码扫描工具cppcheckgcovercoverityfindbugs测试辅助工具抓包工具FlidderWireShark]]></content>
      <categories>
        <category>技术调研</category>
      </categories>
      <tags>
        <tag>测试工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sizeof 和 strlen的区别]]></title>
    <url>%2Fsizeof-%E5%92%8C-strlen%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[先来看一段代码： 123 char* p1 = "helloworld";char p2[] = "helloworld";printf("%d, %d, %d, %d\n", sizeof(p1), strlen(p1), sizeof(p2), strlen(p2)); 运行结果： 4 10 11 10 没错，这就是sizeof和strlen的区别，在字符串长度的计算中。strlen不会加上’\0’.]]></content>
      <categories>
        <category>C/C++基础</category>
      </categories>
      <tags>
        <tag>sizeof</tag>
        <tag>strlen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程互斥与同步（part1）—互斥锁（mutex）的原理及其实现机制]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%88part1%EF%BC%89%E2%80%94%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88mutex%EF%BC%89%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一段代码引发的问题首先，我们来编写一段代码，它的目的是定义一个全局变量，创建两个线程对其进行5000++的操作。 运行结果如下： 当然，目前来看，这段程序并没有任何的问题。 然而，对于此程序，结合线程的特点，我们需要明确两点： 局部变量 i 不是共享的，因为它在栈中 gCount是共享的，因为它是全局变量，属于代码段。 我们知道，只要是共享的资源，那么它就可以看作临界资源，而临界资源的访问需要同步与互斥机制才能维持正常访问。否则可能会出现数据不一致的问题。 下面，我们来讨论一种情况： 假设上边的程序中，线程1先运行。 它在物理内存中读到gcount=0后被切换出去（保存上下文信息）。当线程1重新换回来时，还认为gcount是0，因为它不会再从物理内存中读取。 而此时，线程2开始运行，它在物理内存中也读到gcount=0然后将gcount加到5000，接着又被切换出去。然后线程1再接着运行，将gcount加到1。又被切换了出去。 最后，线程2再运行时也不会再从物理内存中读取gcount的值，它从上下文信息中得知gcount的值为1。这样问题就出现了，本来线程2已经将gcount加到了5000，现在它又从5000变成了1。如此下去，gcount的值就是不确定的。 为什么会出现这样的问题呢？ 这是因为对gcount计数器的操作是非原子性的，所以导致了数据不一致的问题。 多个线程同时访问共享数据时可能会冲突。 比如上边的两个线程都要把全局变量增加1,这个操作在某平台需要三条指令完成: 从内存读变量值到寄存器 寄存器的值加1 将寄存器的值写回内存 假设两个线程在多处理器平台上同时执行这三条指令,则可能导致最后变量只加了一次而非两次。 那为什么上边的程序结果无误呢？ 其实如果是以前的电脑，可能会出错。然而现在的计算机计算速度太快了，线程之间的干扰不够严重。 为了证明确实会出现这种数据不一致的问题，我们对程序进行改造，加大线程之间的干扰力度。 如何加大线程之间的干扰力度呢？有一种比较重要且容易实现的手段：触发线程间切换 知识科普 内核态：操作系统的模式，如果用户或某程序进入了内核态，那么它的权限就会不受约束，可以做任何事。操作系统向外提供系统调用接口方便进行用户态到内核态的转变。 用户态：一般用户的模式，用户或某程序在此状态下只能调用用户代码，权限受约束。当用户想调用系统接口，执行内核代码，就要从用户态变成内核态。 触发线程间切换：在线程执行函数代码中多次进行系统调用，使其不断地从用户态到内核态。这样多个线程之间就会相互干扰。 科普结束。。。 让我们回到问题中，其实上边的程序代码中有一个系统调用：printf 但它调用的次数不够，而且代码也不够复杂，所以对代码进行改造，在“读取全局变量gCount的值”和“把变量的新值保存回去”这两步操作之间插入一个printf调用。它会执行write系统调用进内核，为内核调度别的线程执行提供了一个很好的时机。一个循环中重复上述操作几千次,就会观察到访问冲突的现象。 加入局部变量tmp，使其代替gCount进行++操作，将数据++的过程分成两部分，增加系统调用的次数。改造后的代码如下： 接下来再运行程序，就会出现上述数据不一致导致的错误结果。而且多运行几次，它的结果也是不确定的。 好了，折腾了半天，终于找到了问题。那么如何解决这个问题呢？ 解铃还须系铃人，要解决问题，归根结底就是要解决线程之间互相干扰的问题，从而保证临界资源的原子性。 互斥锁（mutex）就是这里的解铃人。 互斥锁（mutex)对于多线程的程序,访问冲突的问题是很普遍的,解决的办法是引入互斥锁(Mutex,Mutual Exclusive Lock)。 获得锁的线程可以完成“读-修改-写”的操作,然后释放锁给其它线程,没有获得锁的线程只能等待而不能访问共享数据。这样“读-修改-写”三步操作组成一个原子操作,要么都执行,要么都不执行,不会执行到中间被打断,也不会在其它处理器上并行做这个操作。 Mutex⽤用pthread_mutex_t类型的变量表示。 相关函数如下表： 有了互斥锁的概念，下面我们来利用它解决上边的问题，在程序中用宏PTHREAD_MUTEX_INITIALIZER初始化lock互斥锁，并加入加锁解锁函数。修改后代码如下： 我们再来运行代码： 结果正确，说明互斥锁的却解决了问题。 其实，如果我们将代码中循环次数变大，即使没有系统调用触发进程间切换，也会出错。 上边的程序中，将循环次数加到5亿，代码运行结果也是错的。 接着我们加入互斥锁 程序运行结果再次恢复正常（此过程时间较长，因为加锁占用系统资源，程序运行时性能变低（线程在加琐时是串行运行））。 到这里，我们已经解决了问题。 lock和unlock实现原理刚才我们用互斥锁解决了进程切换引发程序运行错误的问题，那么Mutex的两个基本操作lock和unlock是如何实现的呢? 假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁。而Mutex的值为0表示互斥锁已经被某个线程获得,其它线程再调用lock只能挂起等待。 基于此，我们先来看第一种lock和unlock实现的伪代码： 因为unlock过程一定是原子的，所以我们把视线主要集中在lock过程。 我们知道，unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程。然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。 然而仔细观察我们就可以发现问题：上述为代码中lock函数里对Mutex变量的读取、判断和修改并非原子操作。如果两个线程同时调用lock,这时Mutex是1，而两个线程都判断mutex&gt;0成立。然后其中一个线程置 mutex=0，而另一个线程并不知道这一情况,也置mutex=0,于是两个线程都以为⾃⼰获得了锁。 这种情况类似于刚才对全局变量gCount的操作。 因为线程在任何时候都可能被触发导致切换，而在每个线程运行时，mutex都会首先被读到CPU里。这将导致mutex的副本过多，数据依然无法保持一致性。所以这种伪代码的实现是错误的。 下面我们来看另一种实现方法： 首先利用汇编指令xchdb将已置0的寄存器a1与互斥量mutex值进行交换。只对寄存器操作，所以就不会产生物理内存中的mutex副本。这样即使线程在执行xchgb指令和条件判断时被切换出去，也是没有任何意义的，对程序结果并没有影响。unlock中的释放锁操作同样只用一条指令实现,以保证它的原子性。 所以这才是lock和unlock的实现原理。 注：为了实现互斥锁操作,⼤大多数体系结构都提供了swap或exchange指令,该指令的作用是把寄存器和内存单元的数据相交换,由于只有一条指令,保证了原子性,即使是多处理器平台,访问内存的总线周期也有先后,一个处理器上的交换指令执行时另一个处理器的交换指令只能等待总线周期。 知识点：上述为代码中挂起等待和唤醒等待线程操作的实现机制： 每个Mutex都有一个等待队列，一个线程要在Mutex上挂起等待，首先要把自己（pcb）加入等待队列中,然后置线程状态为睡眠状态。然后调用调度器函数切换到别的线程。一个线程要唤醒等待队列中的其它线程，只需从等待队列中取出一 项,把它的状态从睡眠改为就绪，加入就绪队列。那么下次调度器函数执行时就有可能切换到被唤醒的进程。 死锁(Deadlock)正所谓“一波未平，一波又起”，世界上并没有完美的东西。 所以尽管我们能用互斥锁解决线程互斥，但同时互斥锁的引入也会导致另外的问题。这就是死锁。 如果你要问我一个互斥锁会不会产生死锁，我的答案是当然会。试想一下，一个人走在路上自己都能把自己绊倒。那么互斥锁么，呵呵…… 死锁产生原因 情形一：竞争资源 如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁；然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁,。因此就永远处于挂起等待状态了。叫做死锁(Deadlock)。 情形二：线程推进顺序不当 假设线程A获得了锁1，线程B获得了锁2。这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1。于是线程A和B都永远处于挂起状态了。 死锁产生条件 1.互斥2.请求与保持3.不可抢占锁资源4.循环等待 不难想象，如果涉及到更多的线程和更多的锁。死锁的问题将会变得更加复杂和难以判断。 所以，为了避免死锁的产生，使用互斥锁时应尽量避免同时获得多个锁，且应遵循以下原则： 线程在需要多个锁时都按相同的先后顺序(常见的是按Mutex变量的地址顺序)获得锁。⽐如一个程序中用到锁1、锁2、锁3，它们所对应的Mutex变量的地址是锁1&lt;锁2&lt;锁3, 那么所有线程在需要同时获得2个或3个锁时都应该按锁1、锁2、锁3的顺序获得。 尽量使用pthread_mutex_trylock调用代替 pthread_mutex_lock 调用 The End尽管我们可以遵循上面的原则，但还是不能完全避免死锁的产生。 为了解决死锁的问题，需要引入更多的线程互斥与同步机制，如条件变量等。敬请期待Part2.]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>互斥锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱你就像爱生命]]></title>
    <url>%2F%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD%2F</url>
    <content type="text"><![CDATA[你要是愿意，我就永远爱你，你要是不愿意，我就永远相思。 王小波一直是我喜欢的作家之一，更令人惊讶的是，他竟然还是个程序员。 虽然他的作品部部经典，引人深思。但这一篇写给他妻子李银河的情书，却能真正打进人的内心。每看一遍都回味无穷，这是一篇极美的文章，堪称史上写的最好的情书，原来世间仍有这么好的爱。 你要是喜欢了别人我会哭，但是还是喜欢你。 你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。 我是爱你的，看见就爱上了，我爱你爱到不自私的地步，就像一个人手里一只鸽子飞走了，他从心里祝福那只鸽子的飞翔。你也飞吧，我会难过，也会高兴，到底会怎么样我也不知道。 不管我本人多么平庸，我总觉得我对你的爱很美。 我现在已经养成了一种习惯，就是每天要对你说几句不想对别人说的话。 有时候你难过了，这个时候我更爱你，只要你不拒绝我我就拥抱你，我会告诉你这是因为什么，就是我不知道是为了什么。 我爱你，这是我的命运。 我决不为了仪式爱你，我是正经爱你呢。我一正经起来，就觉得自己不坏，生活也真不坏。真的，也许不坏？我觉得信心就在这里。 但愿我和你，是一支唱不完的歌。 我真的是个好人，我对好多人怀有最深的感情，尤其是对你。我很想为别人做好事，尤其是对你，我真想把我做出的一切好事全献给你了。 我们是两个在宇宙里游荡的灵魂，我们不愿孤独，走到一起来，别人与我们无关。我把我的整个灵魂给你，连同它的怪癖耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。 只希望你和我好，互不猜忌，也互不称誉，安如平日，你和我说话像对自己说话一样，我和你说话也像对自己说话一样。 说吧，和我好吗？]]></content>
      <categories>
        <category>美文</category>
      </categories>
      <tags>
        <tag>王小波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAT&代理服务器技术调研]]></title>
    <url>%2FNAT-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[相信用过facebook等其他国外社交网站的小伙伴，都离不开一个东西——**软件。 为什么不能直接通过网络连接访问这些网站，而要借助于这些软件呢？这个嘛，你懂得。。。 本文将介绍其背后的机制：NAT&amp;代理服务器技术 Key Point： 引言：为什么需要NAT&amp;代理服务器技术 2者概念及区别 引言 如果一个组织内部组建了局域网，那么IP地址将只用于局域网内的通信，而不直接连到Internet上。 理论上，使用任意的IP地址都可以连接网络，但是RFC1918规定了用于组建局域网的私有IP地址，这些地址不会出现在Internet上。 那这些私有IP地址就不能连接Internet了么？ So…… 使用私有IP地址的局域网主机虽然没有Internet的IP地址，但也可以通过代理服务器或NAT(网络地址转换)等技术连到Internet上。 Concept NAT技术 概念关于NAT技术，百度百科的介绍是这样的： 博主最近又开始在百度盗图了，我的错，我有罪╮(╯﹏╰）╭ 根据概念我们可以总结： 所谓NAT技术，就是在一个主机只能有一个IP地址的情况下，利用NAT路由器，将自身IP地址转换为一个有效的外部全球地址，从而连接全球Internet的技术。 技术背景再来818它的技术背景： 所以，路由器真是个好东西୧(๑•̀⌄•́๑)૭碉堡 到这里，相信你已经对NAT技术有一个大致的了解了，但是我们还要知道它的原理和工作流程。 原理和工作流程 从上边的概念我们可以知道，借助于NAT，私有（保留）地址的”内部”网络通过路由器发送数据包时，私有地址被转换成合法的IP地址，一个局域网只需使用少量IP地址（甚至是1个）即可实现私有地址网络内所有计算机与Internet的通信需求。 再来看一下它的工作原理： Step1： client（终端） 的 gateway （网关）设定为 NAT 主机，当要连上 Internet 的时候，该封包就会被送到 NAT 主机，这个时候的封包 Header 之 source IP（源IP） 为 192.168.1.100 Step2： NAT 主机将 client 的对外联机封包的 source IP ( 192.168.1.100 ) 伪装成 ppp0 ( 假设为拨接情况 )这个接口所具有的公共 IP ，因为是公共 IP 了，所以这个封包就可以连上 Internet 了，同时 NAT 主机会记忆这个联机的封包是由哪一个 ( 192.168.1.100 ) client 端传送来的 Step3： Internet 传送回来的封包由 NAT主机来接收，NAT 主机查询原本记录的路由信息，并将目标 IP 由 ppp0 上面的公共 IP 改回原来的 192.168.1.100 Step4： 由 NAT 主机将该封包传送给原先发送封包的 Client 这就是NAT技术的原理。 代理服务器技术 概念 所谓“代理”，就是代而劳之的意思。代理服务器就是代理网络用户去取得网络信息，形象的说：它是网络信息的中转站，使得一个网络终端和另一个网络终端不直接进行相连，而由代理服务器代理网络用户去取得信息。主要工作在OSI的会话层中。 功能代理服务器（Proxy Server）是Internet链路级网关所提供的一种重要的安全功能，主要的功能有： 工作流程一个完整的代理请求过程为： Step1： 客户端与代理服务器创建连接，接着根据代理服务器所使用的代理协议，请求对目标服务器创建连接或者获得目标服务器的指定资源（如文件）。 Step2： 如果客户端索要获取的资源在代理服务器的缓存之中，则代理服务器并不会向目标服务器发送请求，而是直接返回缓存的资源。 注意以下几点： 一些代理协议允许代理服务器改变客户端的原始请求、目标服务器的原始响应，以满足代理协议的需要。 代理服务器的选项和设置在计算机程序中，通常只包括一个“防火墙”，允许用户输入代理地址，他会这该他们的网络活动，可以允许绕过互联网过滤实现网络访问。 区别 虽然NAT技术和代理服务器技术都可以解决“翻墙”问题，但他们的区别可不小。 突出在以下几点： 运算成本和网络性能方面 NAT:使用路由器，成本较低 代理服务器：成本较高 网络安全性方面 NAT: 工作原理决定了IP地址不能隐藏，用户主机容易受到攻击 代理服务器：用户可以隐藏IP地址，以防受到攻击，安全性较高 访问速度 NAT: 工作流程使访问速度受限 代理服务器：设置了一个较大的硬盘缓冲区，当有外界的信息通过的时候，同时也将其保存在缓冲区中，当其他用户在访问相同的信息时，则直接有缓冲区取出信息，传给用户，以提高访问速度 IP开销 NAT: 要为局域网（LAN）内的每一个用户都申请一个IP地址 代理服务器：允许使用大量的伪IP地址，节约上网资源，即代理服务器可以减少对IP地址的需求 The End 知道了这两个技术，以后看到舍友用facebook的时候还能顺便装个逼。妙哉妙哉…… 本文引用： NAT技术百度百科 代理服务器和NAT技术 本文首次发表在博主的CSDN博客，链接：http://blog.csdn.net/summy_j/article/details/74145017]]></content>
      <categories>
        <category>技术调研</category>
      </categories>
      <tags>
        <tag>NAT</tag>
        <tag>代理服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GithubPages&CodingPages搭建自己的个人博客]]></title>
    <url>%2FHexo-GithubPages-CodingPages%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[首先声明：这并不是一篇教程。 字数这么多，先来首音乐压压惊： 这不是一篇教程，原因有4个： 博主太懒了，而且文笔也很差。 写教程需要把之前的过程再过一遍，博主没有时间也没有耐心。 中间要在github上创建个人的github.io库，而这个库每个账号只能有一个。为了写教程再去申请账号太麻烦了。 最后一点，也是最重要的一点：网上的教程已经很多了，而且有的文章写的确实不错。我的博客就是参考网上的教程搭建的，既然我没有人家写得好，就没有必要写。 我想有的人会问了：那这篇文章是干嘛的呢？ 问得好。 我想在你看到我的这篇文章之前，各位小可爱一定还见过或者收藏了其他关于搭建博客的的文章，以便对比，查漏补缺式的开始搭建。博主搭建博客的时候也是这么做的。 所以，本文将把我从开始想搭建博客，到最后搭建成功的整个过程中，用到的所有文章链接做一个汇总。这样可以减少你在网上搜索教程，过滤有用文章的时间。而且还方便博主以后查看，让一切变得简单。 怎样汇总呢？ 我是这样做的，把文章分为5个部分。根据我的经验，这5个部分是你整个博客搭建过程中必须要思考和实践的： 前言：搭建博客难吗 &amp; 为什么要搭建博客 背景知识：Hexo &amp; Github &amp; GithubPages &amp; CodingPages 搭建过程：重头戏 个性化：本文链接最多的一个部分，原因你懂的 我的建议和踩过的坑 最后一个部分穿插在前4个部分中，能让你更快的进行博客搭建，所以不作为单独的目录出现。 如果你不想了解前两个部分，可以直接跳到第3部分。 好了，废话就不多说了，开车! 前言搭建博客难吗？我可以很负责人的告诉你：不仅不难，而且还很简单。 那么，只有程序员才能搭建博客吗？ 或许你不相信，但我确实见过有许多非互联网行业的人也搭建了自己的博客。所以在搭建博客这件事上，确实没有专业之分。 说白了，搭建博客就是用一堆别人的东西，来做一个你自己的东西：Hexo、主题、GithubPages、CodingPages，这些没一样是你的。而且这些都是免费的，除了买域名要花一只棒棒糖的钱（我搭建博客一共就花了3块钱） 所以，人家设计的东西，你只要拿来用就可以了。 需要自己知道一些背景知识吗？上边说了，搭建博客是没有专业之分的。你可以不知道什么是Github,hexo,GithubPages/CodingPages。甚至在技术方面什么也不懂。 可能你不相信，但结合我的搭建过程，我可以先给你说说他们都是怎么用的： Github：只是建立了一个github.io的库，没有账号的话可以注册一个。所以你有没有账号，会不会操作Github都没有关系。 Hexo：只是下载了它的安装包和主题，你只需要知道一些部署博客的命令（不超过5条）。这些命令你也可以不会，因为文档里都有。 GithubPages：是Github推出的功能，只要你建立了github.io库，就默认在使用。它相当于一个服务器，可以保存你的所有博客文件，是你电脑上博客站点的一份备份。也不用你了解。 CodingPages：跟GithubPages作用相同，也是为了备份。所以你可以不用这个。但这个是国内的。为了双重保障和你的博客运行速度。建立还是设置下它。 它们的概念下边会详细介绍。 当然，搭建博客时你可以什么都不懂。但为了以后能更好的操作你的博客，建议在搭建成功之后，好好学习一下Github的使用。网上的教程也有很多，这里就不再赘述。 虽然你可以什么都不懂，但以下3样东西你必须要有： 耐心：搭建博客是一件非常折腾的事情，所以耐心很重要 细心：一定要细心，确保每一步都是正确的。 一定的学习能力和钻研精神，遇到困难一定要面对它，主动解决。 为什么搭建博客？这个问题相信你已经有了自己的答案，但我还是建议你看看这2篇文章： 我为什么坚持写博客？ 为什么你要写博客？ 搭建博客需要多长时间？这个因人而异，在我看来，有这么几种： 半天：只是搭建，不涉及到换域名和个性化，并且了解背景知识。那么只要半天便可以搭建完成 一天：需要了解背景知识，并且换了域名和主题，但没有太多的个性化 两天：设置了评论，字数统计等各种个性化设置（比如我） 三天甚至更多：各种找个性化插件和设置，一直在折腾的人 当然，前两种都是你没有遇到太大的坑或者困难所给出的估计时间。如果你在搭建的时候碰到了很多的问题，那么这个时间就得延长了。因为这种问题一般不好查。 背景知识搭建博客之前，你应该知道自己在做的是什么。先把事情做对，再把事情做好。所以你需要了解一些背景知识。 建立博客的渠道 通常来说，建立博客的通常渠道包括以下3种： 在博客平台上注册，比如 博客园、CSDN、新浪博客 等。 利用博客框架搭建，如 WordPress、Jekyll、hexo 等。 自己用代码写一个。 其中，第一种最简单，也最受限，说不定还会被删帖删号（我就遇到过这种情况）。第二种稍复杂，另外需要自己找部署的服务器，但可定制化较高，是很多人的选择。最后一种，是在重复造轮子，不过从另一个方面来看，倒是锻炼编程能力的好方式。 而我们要做的，就是第二种：既不受限，难度也不大。 为什么选择GithubPages和Hexo用第二种方式搭建博客也有很多方法，但主流的有两种： Wordpress GitHub Pages+Hexo 很多人用 Wordpress，为什么我要用 GitHub Pages 来搭建？ 开始我也不知道用哪个，但在网上搜了教程后，发现wordpress比Hexo要麻烦很多。 Hexo是开源在Github上的，而且轻快便捷 GitHub Pages 有 300M 免费空间，资料自己管理，保存可靠。 学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多 顺便看看 GitHub 工作原理，最好的团队协作流程 GitHub 是趋势 概念介绍HEXOHexo 是一个简单、快速、强大的静态博客框架，基于Node.js。由台湾大学生tommy351创建。并把它开源到了Github上，这里是它在Github上的地址：HexoGithub，它主要有以下优点： 极速生成静态页面 一键部署博客 丰富的插件支持 支持 Markdown 更多内容可以查看Hexo的官方文档，建议你只看看介绍部分，其它的你现在也看不太懂。等你搭建好了博客再去详细了解其他的内容就会轻松很多：Hexdocs GitHubGitHub是一个代码托管网站和社交编程网站。这里聚集了世界上各路技术牛叉的大牛，和最优秀的代码库。是全球程序员的天堂。因为是国外的，所以界面全是英文。博主英语过了六级刚开始接触的时候心都突突，不过不要怕，不是还有翻译么， 也有好多人调侃它是全球同性交友平台，其实我不太懂这个梗（女程序员也是很多的好么） GitHub PagesGitHub Pages是用来托管 GitHub 上静态网页的免费站点，其他的不多说。 CodingPages和GithubPages功能相同，其对应的Coding平台也可以实现和Github相似的功能。但没有后者那么出名。是香港的公司，也算是国内的。 看了这些，我相信你一定还是一脸懵逼的。但你可以简单理解成下边的的一段话： 利用Hexo和GithubPages/CodingPages搭建博客，实际上就是利用Hexo在本地（你的电脑上）生成一个博客站点，然后利用网络将它传输到Github/Coding上进行拷贝和备份。再由Github和Coding提供的GithubPages/CodingPages服务将博客部署到网上，这样你的博客就可以作为一个独立的站点被别人浏览（正式上线）。同时你也可以在Github和Coding上管理你的博客。 如果你还想了解更多背景知识，可以看看这篇文章：搭建个人博客，你需要知道这些 搭建过程搭建步骤一般来说，搭建博客有以下几个步骤： 获得个人网站域名 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 推送网站 绑定域名 在Coding上部署你的网站 其中，1.7.8你可以不做。但剩下的必须要做，一步都不能少，也不能错。在你看下边推荐的博客的时候，不要忘记看看我下边的建议。 1-7步请看：这篇博客不只前7步，如果你做完了就可以往下做，因为后边的都是属于个性化部分，所以博主在这里没有显示。GitHub+Hexo 搭建个人网站详细教程 第8步请看：这篇博客是在你做完了前7步的基础上做的。hexo干货系列：（四）将hexo博客同时托管到github和coding，这篇博客也讲了怎么在CodingPages部署，可以和上一篇对照着看：我的Hexo博客站的创建历程(一)【Github&amp;Coding双管齐下部署Hexo】 我的建议和踩过的坑 第一篇： 域名建议买.top，比较便宜。当然，土豪随意。 下载Node.js或Git时，由于众所周知的原因，下载速度会很慢。这时你需要看Hexo的官方文档，上边给出了离线下载的地址：Hexdocs 在安装Hexo这一步，hexo init blog及其之后的命令都是在Blog/blog这个目录下进行的，一定要注意，不能弄错了。博主刚开始就是搞错了路径，结果一直报错。。。 在初始化这一步，如果报出了“Please tell me who you are”的错误，要下载Github桌面程序来解决。这样初始化时就会自动弹出登录窗口，直接登录就可以了。又是因为众所周知的原因，官方下载会很慢，所以博主分享了离线版：点击下载 如果你在安装Hexo或者之前的步骤中有报错，建议你重新下载安装。因为这之前的过程全是安装的部分，一旦出错，没有别的原因，一定是你的操作有问题。而且你解决错误的时间一定要比重新安装耗费的时间长。 关于Markdown，建议用文中推荐的markdownPad2，下载后预览功能不能使用的问题需要下载插件,部分功能要升级到专业版才可以使用。这两个问题都可以百度解决。 第二篇： 1.关于域名绑定，再次说明。血的教训告诉我们，Only需要添加两个解析。没有A记录，like this： 之后可以在此网站对你的博客进行测试，看看你的博客是否可以在国内解析到Coding，国外解析到Github。访问速度是否得到提升。以下是博主的测试结果： 2.coding配置完成后，加载博客时会出现其广告界面： 如果你想去掉呢，coding也给出了解决办法。但是你不觉得这个界面做的很小清新吗，还可以提升逼格。所以博主就不去掉啦٩(๑&gt;◡&lt;๑)۶ 个性化 终于到了万众瞩目的个性化步骤了，到这里，想必你已经根据博主推荐的链接成功搭建好了博客。 下面来具体说说个性化。 主题选择如果你按照上边搭建博客时推荐的文章那样，选择了next主题。那就不用多说。如果你觉得next主题不符合你的Style，可以参考这篇文章选择你喜欢的主题：Hexo博客主题推荐 但我还是推荐你用next主题，原因： next主题是github上最流行的主题，star和fork的数量远远超过了别的主题。所以相信群众的选择。 next主题的主题配置文件本就内置了许多插件，在个性化的过程中你只需要把flase改成true或者加上对应服务的id就可以直接使用。极为方便。这是其他很多主题没有做到的一点 next主题内部还分为4个主题方案：Muse、Mist、Pisces、Gemini，可以自由选择，更加多元化。我选择的是Pisces。 界面高端大气，配色低调奢华。 ps：如果你没有用next主题，那么以下个性化设置就不用看了。因为它们都是next的配置。 按照主题文档设置选定了主题后，建议先看看主题的文档进行个性化设置。里面是最基本的标签、分类设置，还有第三方服务设置：next主题配置 其他的个性化设置因为用的是next主题，所以这里也是针对于next主题的个性化配置。我博客的所有个性化都是来自这些链接： 网易云音乐链接设置，参考博客搭建时推荐的第一篇博客 这一篇看它的个性化设置部分：Hexo搭建博客教程 RSS和High特效 这篇真的厉害了，有30种特效：hexo的next主题个性化教程:打造炫酷网站 主讲第3方服务：配置第三方服务 这个也很方便，创建新文章后不用再去找了：Hexo添加文章时自动打开编辑器 创建一个菜单页面作为文章目录：hexo下新建页面下如何放多个文章 博客加密：加密插件Github，issue里有解决next主题兼容的方法 上边这些链接里的设置，均为博主亲测有效。从这些链接可以看出，博主也是折腾了很久的。。。 鬼知道我经历了什么 在Github上看issue或者提issue如果你还想折腾，还有两种途径： 可以看看next在Github上的issue：这些都是别人提的，可能会有你想要的设置。如果你遇到了问题，也可以自己提issue。这是网址：next/issues 去Hexo的官方插件页面找，这里的插件很多。只有你想不到，没有你找不到：Hexo插件 我的建议 个性化固然好，但是在设置的时候一定要细心，这些都是要打开代码文件去修改的。建议不要用记事本或写字板打开，可以用VS编辑器打开，不仅方便查错和回退，还便于查找。这里举一个在VS查找的例子： 比如你要设置字数统计功能，你不知道在哪找，但你看到对应的文章中有这样一行:#Post wordcount display settings，你就可以点击右上方的查找图标，输入这行代码，选择全部匹配。就可以定位到你要设置的那部分。 如果你在个性化设置的时候碰到了中文乱码的问题，也可以在VS中点击文件-&gt;高级保存选项-&gt;把编码改成unicodeutf8选项即可 评论功能我推荐来必力和畅言，前者不需要域名备案，直接就可以使用，但界面较丑。后者要进行域名备案才能使用，但界面美观大气，看你怎么选。 关于图床，还是建议用七牛，这也是大多数人的选择，但得到图片外链要4步，很麻烦。网上也有人用插件直接拖拽图片上传得到外链，但好像没有windows平台的。反正我没有找到，麻烦就麻烦一点吧。如果你找到了，可以在下方给我留言。 一定要细心，建议改一项个性化，先不要关闭你改过的文件，在重新生成部署没有错之后在关闭，这样出错了也好改回去。博主有一次就是不知道自己改了啥，结果出错了，幸好根据出错信息定位到了两个文件，然后重新下载了一份干净的next文件作对比，才改过来。所以，一定不要作死。 虽然个性化是可以让你的博客看起来高大上许多，但是不要太过了。忘了自己搭建博客的初心，只有文章才是最重要的，而且太多的个性化会影响博客的加载速度，得不偿失。 强烈建议：把站点文件做一个备份，like this： 这样做可以方便你查错，而且一旦你操作出错，至少还有一个可以运行成功的站点。不用再担惊受怕(・ω&lt;)。还可以将这两个文件都上传到云上，推荐坚果云。因为它可以自动监测更改的文件，并将更改上传到云上。 网站链接 下面是博客搭建过程中用到的一些平台和网站的链接，比如Livere提供的评论功能，七牛图床等： Hexo: https://hexo.io/ 阿里云: https://www.aliyun.com/ Livere: https://livere.com/ Leancloud: https://leancloud.cn/ 七牛: https://www.qiniu.com/ The End终于写完啦，如果除了文中博主提到的点。你还有其它问题，可以在评论区留言，我每一条都会回复哦~ ps:近来发现文中有的链接已经失效啦，小伙伴们可以自行搜索哈。。。]]></content>
      <categories>
        <category>学习小记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GithubPages</tag>
        <tag>CodingPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SecondPage]]></title>
    <url>%2FSecondPage%2F</url>
    <content type="text"><![CDATA[嗯，我确实不是一个善于起名字的人，但明天的文章绝对不是ThirdPage 先来张美图洗洗眼： 安利一个找图网站，花瓣网：http://huaban.com/。 里面的图片真的挺不错的，插画和风景图都好看。可以定时去洗洗眼٩(๑&gt;◡&lt;๑)۶ ，这可不是广告哦。 说说今天吧，其实早有想法做一个自己的博客，上次在某博客网站发布文章，结果账号一言不合被封杀。。。 当时心里就挺不爽的，随之有了搭建个人博客的想法。 因为太懒了，所以现在才行动。嗯。。。（我是不是承认了什么） 在网上找了很多教程，有WordPress搭建的，还有Hexo和Github，想了想还是后者吧。看着比较简单。 然而不是我太笨，就是我想多了。从昨晚开始搭建博客，中间踩了无数的坑，重构了几次，结果到现在才初见雏形。而且域名还没有绑定成功。。。 内心无比暴躁，伐开森。。 但今天也快完了，就只能到这里了。明天应该就完整的搭建好了吧（是的吧）。 要是明天还不成功，我就，我就，就 ps：我不会承认这是一篇凑个数的文章。。]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TC]]></title>
    <url>%2FFirstBlog%2F</url>
    <content type="text"><![CDATA[Charge for non-free Videos 测哪\咋测 功能测试 集成测试 性能测试 安全测试 端到端 test test test test API test test test test 类 test test test test 方法 test test test test Advertisement]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
